<!DOCTYPE html>
<html xmlns:wb="http://open.weibo.com/wb">
<head>
  <meta charset="utf-8">
  <script src="https://cdn.jsdelivr.net/gh/Sanarous/files@1.13/js/linkcard.js"></script>
  <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?20f0ea98b3ba0ec3c95a03b3caf626d9";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  
  <title>我的书单 | 涂宗勋的博客</title>
  <meta name="baidu-site-verification" content="o8pWlgAEZ7" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我的书单我习惯看纸质的书，但为了方便喜欢看电子版的朋友，这里也提供一些我所知道的电子版链接，不保证版本号都对，有的找不到（文末有他人推荐书单）  2017年（已购纸质书籍）    书籍照片 书名及电子书链接 简介和目录 读书笔记     《java核心技术 卷1 第10版》 简介和目录 -    《effective java中文版 》(暂无电子版链接) 简介和目录 -    《java编程思想">
<meta property="og:type" content="website">
<meta property="og:title" content="我的书单">
<meta property="og:url" content="https://blog.tzxcode.cn/books/index.html">
<meta property="og:site_name" content="涂宗勋的博客">
<meta property="og:description" content="我的书单我习惯看纸质的书，但为了方便喜欢看电子版的朋友，这里也提供一些我所知道的电子版链接，不保证版本号都对，有的找不到（文末有他人推荐书单）  2017年（已购纸质书籍）    书籍照片 书名及电子书链接 简介和目录 读书笔记     《java核心技术 卷1 第10版》 简介和目录 -    《effective java中文版 》(暂无电子版链接) 简介和目录 -    《java编程思想">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/hexin1.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/effjava.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/bianchengsixiang.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/bingfabiancheng.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/bingfashizhan.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/javamianshi.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/javaweb.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/javayouhua.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/spring.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/springboot.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/springmvc.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/mavenshi.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/eclipse.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/tomcat.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/headfirst.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/shejimoshi.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/bianma.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/redis.png">
<meta property="og:image" content="https://blog.tzxcode.cn/images/books/mysql.png">
<meta property="article:published_time" content="2017-09-24T08:43:52.000Z">
<meta property="article:modified_time" content="2020-06-19T07:00:33.355Z">
<meta property="article:author" content="涂宗勋">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tzxcode.cn/images/books/hexin1.png">
  
  
    <link rel="icon" href="/images/touxiang.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <script src="https://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
  <script src="https://cdn.jsdelivr.net/gh/Sanarous/files@1.13/js/linkcard.js"></script>
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.tzxcode.cn"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/shuoshuo/">说说</a>
        
          <a class="main-nav-link" href="/archives/">归档</a>
        
          <a class="main-nav-link" href="/collections/">收藏</a>
        
          <a class="main-nav-link" href="/download/">资源</a>
        
          <a class="main-nav-link" href="/about/">简历</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">涂宗勋的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">5年java工作经验，CSDN博客专家，爱好分享，CSDN博客https://blog.csdn.net/tuzongxun</a>&nbsp;&nbsp;&nbsp;&nbsp;
		  <!--<span id="busuanzi_container_site_pv">【本站累计访问量:<span id="busuanzi_value_site_pv"></span>】</span>-->
        </h2>
		
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="page-" class="article article-type-page" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/books/index.html" class="article-date">
  <time datetime="2017-09-24T08:43:52.000Z" itemprop="datePublished">2017-09-24</time>
</a>
    
</span>
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      我的书单
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <hr>
<h1 id="我的书单"><a href="#我的书单" class="headerlink" title="我的书单"></a>我的书单</h1><p><strong>我习惯看纸质的书，但为了方便喜欢看电子版的朋友，这里也提供一些我所知道的电子版链接，不保证版本号都对，有的找不到</strong>（文末有他人推荐书单）</p>
<hr>
<h2 id="2017年（已购纸质书籍）"><a href="#2017年（已购纸质书籍）" class="headerlink" title="2017年（已购纸质书籍）"></a>2017年（已购纸质书籍）</h2><hr>
<table>
<thead>
<tr>
<th>书籍照片</th>
<th>书名及电子书链接</th>
<th align="center">简介和目录</th>
<th align="center">读书笔记</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/images/books/hexin1.png" alt="java核心"></td>
<td><a href="http://www.gaofi.cn/book/reading/53" target="_blank" rel="noopener">《java核心技术 卷1 第10版》</a></td>
<td align="center"><a href="#java核心技术">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/effjava.png" alt="effjava"></td>
<td>《effective java中文版 》(暂无电子版链接)</td>
<td align="center"><a href="#effectivejava中文版">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/bianchengsixiang.png" alt="java编程思想"></td>
<td><a href="#已购书籍简介">《java编程思想 第四版 》</a></td>
<td align="center"><a href="#java编程思想">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/bingfabiancheng.png" alt="并发核心"></td>
<td>《java并发编程核心方法与框架 》(暂无电子版链接)</td>
<td align="center"><a href="#java并发编程核心方法与框架">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/bingfashizhan.png" alt="并发实战"></td>
<td>《java并发编程实战 》(暂无电子版链接)</td>
<td align="center"><a href="#java并发编程实战">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/javamianshi.png" alt="javamianshi"></td>
<td>《java面试宝典 》(暂无电子版链接)</td>
<td align="center"><a href="#java面试宝典">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/javaweb.png" alt="javaweb"></td>
<td>《深入分析java web技术内幕 》(暂无电子版链接)</td>
<td align="center"><a href="#深入分析javaweb技术内幕">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/javayouhua.png" alt="javayouhua"></td>
<td>《java性能优化权威指南 》(暂无电子版链接)</td>
<td align="center"><a href="#java性能优化权威指南">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/spring.png" alt="spring"></td>
<td>《spring入门经典》(暂无电子版链接)</td>
<td align="center"><a href="#spring入门经典">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/springboot.png" alt="springboot"></td>
<td>《spring boot实战 》(暂无电子版链接)</td>
<td align="center"><a href="#springboot实战">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/springmvc.png" alt="spring mvc"></td>
<td>《spring mvc学习指南 》(暂无电子版链接)</td>
<td align="center"><a href="#springmvc学习指南">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/mavenshi.png" alt="maven实战"></td>
<td><a href="http://www.gaofi.cn/book/reading/5611" target="_blank" rel="noopener">《maven实战 许晓斌著》</a></td>
<td align="center"><a href="#maven实战">简介和目录</a></td>
<td align="center"><a href="https://tuzongxun.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/maven/" target="_blank" rel="noopener">maven实战读书笔记分类</a></td>
</tr>
<tr>
<td><img src="/images/books/eclipse.png" alt="eclipse"></td>
<td>《eclipse精粹 》(暂无电子版链接)</td>
<td align="center"><a href="#eclipse精粹">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/tomcat.png" alt="tomcat"></td>
<td>《tomcat权威指南 》(暂无电子版链接)</td>
<td align="center"><a href="#tomcat权威指南">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/headfirst.png" alt="headfirst设计模式"></td>
<td>《head first设计模式 》(暂无电子版链接)</td>
<td align="center"><a href="#headFirst设计模式">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/shejimoshi.png" alt="设计模式"></td>
<td>《设计模式 》(暂无电子版链接)</td>
<td align="center"><a href="#设计模式">简介和目录</a></td>
<td align="center"><a href="https://tuzongxun.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">设计模式读书笔记分类</a></td>
</tr>
<tr>
<td><img src="/images/books/bianma.png" alt="编码"></td>
<td>《编码 CODE 》(暂无电子版链接)</td>
<td align="center"><a href="#编码">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/redis.png" width="50%" height="50%" /></td>
<td>《redis开发与运维 付磊、张益军著》(暂无电子版链接)</td>
<td align="center"><a href="#redis开发与运维">简介和目录</a></td>
<td align="center">-</td>
</tr>
<tr>
<td><img src="/images/books/mysql.png" width="50%" height="50%" /></td>
<td>《mysql从入门到精通 》(暂无电子版链接)</td>
<td align="center"><a href="#mysql从入门到精通">简介和目录</a></td>
<td align="center">-</td>
</tr>
</tbody></table>
<hr>
<h1 id="他人推荐书单"><a href="#他人推荐书单" class="headerlink" title="他人推荐书单"></a>他人推荐书单</h1><p><a href="http://zh.lucida.me/blog/developer-reading-list/#foundation" target="_blank" rel="noopener">Lucida推荐程序员必读书单 1.0</a></br><br><a href="http://blog.jobbole.com/106093/" target="_blank" rel="noopener">博客在线推荐书单</a></br><br><a href="http://calvin1978.blogcn.com/articles/javabookshelf.html" target="_blank" rel="noopener">江南白衣推荐书单1</a></br><br><a href="http://calvin1978.blogcn.com/articles/bookshelf16.html" target="_blank" rel="noopener">江南白衣推荐书单2</a></br><br><a href="http://wdxtub.com/1997/09/11/booklist-page/" target="_blank" rel="noopener">小土刀书影音</a></br></p>
<hr>
<h1 id="已购书籍简介和目录"><a href="#已购书籍简介和目录" class="headerlink" title="已购书籍简介和目录"></a>已购书籍简介和目录</h1><hr>
<h2 id="java核心技术"><a href="#java核心技术" class="headerlink" title="java核心技术"></a>java核心技术</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Java领域最有影响力和价值的著作之一，由拥有20多年教学与研究经验的资深Java技术专家撰写(获Jolt大奖)，与《Java编程思想》齐名，10余年全球畅销不衰，广受好评。第10版根据Java SE 8全面更新，同时修正了第9版中的不足，系统全面讲解了Java语言的核 心概念、语法、重要特性和开发方法，包含大量案例，实践性强。<br>一直以来，《Java核心技术》都被认为是面向高级程序员的经典教程和参考书，它内容翔实、客观准确，不拖泥带水，是想为实际应用编写健壮Java代码的程序员的首选。如今，本版进行了全面更新， 以反映近年来人们翘首以待、变革最大的Java版本（Java SE 8）的内容。这一版经过重写，并重新组织，全面阐释了新的Java SE 8特性、惯用法和<em>佳实践，其中包含数百个示例程序，所有这些代码都经过精心设计，不仅易于理解，也很容易实际应用。<br>本书为专业程序员解决实际问题而写，可以帮助你深入了解Java语言和库。在卷I中，Horstmann主要强调基本语言概念和现代用户界面编程基础，深入介绍了从Java面向对象编程到泛型、集合、lambda表达式、Swing UI设计以及并发和函数式编程的</em>新方法等内容。</p>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/26880667/" target="_blank" rel="noopener">https://book.douban.com/subject/26880667/</a></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>第1章　Java程序设计概述 1<br>1.1　Java程序设计平台 1<br>1.2　Java“白皮书”的关键术语 2<br>1.2.1　简单性 2<br>1.2.2　面向对象 2<br>1.2.3　分布式 3<br>1.2.4　健壮性 3<br>1.2.5　安全性 3<br>1.2.6　体系结构中立 4<br>1.2.7　可移植性 4<br>1.2.8　解释型 5<br>1.2.9　高性能 5<br>1.2.10　多线程 5<br>1.2.11　动态性 5<br>1.3　Java applet与Internet 6<br>1.4　Java发展简史 7<br>1.5　关于Java的常见误解 9<br>第2章　Java程序设计环境 12<br>2.1　安装Java开发工具包 12<br>2.1.1　下载JDK 12<br>2.1.2　设置JDK 13<br>2.1.3　安装库源文件和文档 15<br>2.2　使用命令行工具 16<br>2.3　使用集成开发环境 18<br>2.4　运行图形化应用程序 21<br>2.5　构建并运行applet 23<br>第3章　Java的基本程序设计结构 28<br>3.1　一个简单的Java应用程序 28<br>3.2　注释 31<br>3.3　数据类型 32<br>3.3.1　整型 32<br>3.3.2　浮点类型 33<br>3.3.3　char类型 34<br>3.3.4　Unicode和char类型 35<br>3.3.5　boolean类型 35<br>3.4　变量 36<br>3.4.1　变量初始化 37<br>3.4.2　常量 37<br>3.5　运算符 38<br>3.5.1　数学函数与常量 39<br>3.5.2　数值类型之间的转换 40<br>3.5.3　强制类型转换 41<br>3.5.4　结合赋值和运算符 42<br>3.5.5　自增与自减运算符 42<br>3.5.6　关系和boolean运算符 42<br>3.5.7　位运算符 43<br>3.5.8　括号与运算符级别 44<br>3.5.9　枚举类型 45<br>3.6　字符串 45<br>3.6.1　子串 45<br>3.6.2　拼接 46<br>3.6.3　不可变字符串 46<br>3.6.4　检测字符串是否相等 47<br>3.6.5　空串与Null串 48<br>3.6.6　码点与代码单元 49<br>3.6.7　String API 50<br>3.6.8　阅读联机API文档 52<br>3.6.9　构建字符串 54<br>3.7　输入输出 55<br>3.7.1　读取输入 55<br>3.7.2　格式化输出 58<br>3.7.3　文件输入与输出 61<br>3.8　控制流程 63<br>3.8.1　块作用域 63<br>3.8.2　条件语句 63<br>3.8.3　循环 66<br>3.8.4　确定循环 69<br>3.8.5　多重选择：switch语句 72<br>3.8.6　中断控制流程语句 74<br>3.9　大数值 76<br>3.10　数组 78<br>3.10.1　for each循环 79<br>3.10.2　数组初始化以及匿名数组 80<br>3.10.3　数组拷贝 81<br>3.10.4　命令行参数 81<br>3.10.5　数组排序 82<br>3.10.6　多维数组 85<br>3.10.7　不规则数组 88<br>第4章　对象与类 91<br>4.1　面向对象程序设计概述 91<br>4.1.1　类 92<br>4.1.2　对象 93<br>4.1.3　识别类 93<br>4.1.4　类之间的关系 94<br>4.2　使用预定义类 95<br>4.2.1　对象与对象变量 95<br>4.2.2　Java类库中的LocalDate类 98<br>4.2.3　更改器方法与访问器方法 100<br>4.3　用户自定义类 103<br>4.3.1　Employee类 103<br>4.3.2　多个源文件的使用 105<br>4.3.3　剖析Employee类 106<br>4.3.4　从构造器开始 106<br>4.3.5　隐式参数与显式参数 108<br>4.3.6　封装的优点 109<br>4.3.7　基于类的访问权限 111<br>4.3.8　私有方法 111<br>4.3.9　final实例域 112<br>4.4　静态域与静态方法 112<br>4.4.1　静态域 112<br>4.4.2　静态常量 113<br>4.4.3　静态方法 114<br>4.4.4　工厂方法 115<br>4.4.5　main方法 115<br>4.5　方法参数 118<br>4.6　对象构造 123<br>4.6.1　重载 123<br>4.6.2　默认域初始化 123<br>4.6.3　无参数的构造器 124<br>4.6.4　显式域初始化 125<br>4.6.5　参数名 125<br>4.6.6　调用另一个构造器 126<br>4.6.7　初始化块 127<br>4.6.8　对象析构与finalize方法 130<br>4.7　包 131<br>4.7.1　类的导入 131<br>4.7.2　静态导入 133<br>4.7.3　将类放入包中 133<br>4.7.4　包作用域 136<br>4.8　类路径 137<br>4.8.1　设置类路径 139<br>4.9　文档注释 140<br>4.9.1　注释的插入 140<br>4.9.2　类注释 140<br>4.9.3　方法注释 141<br>4.9.4　域注释 142<br>4.9.5　通用注释 142<br>4.9.6　包与概述注释 143<br>4.9.7　注释的抽取 143<br>4.10　类设计技巧 144<br>第5章　继承 147<br>5.1　类、超类和子类 147<br>5.1.1　定义子类 147<br>5.1.2　覆盖方法 149<br>5.1.3　子类构造器 150<br>5.1.4　继承层次 153<br>5.1.5　多态 154<br>5.1.6　理解方法调用 155<br>5.1.7　阻止继承：final类和方法 157<br>5.1.8　强制类型转换 158<br>5.1.9　抽象类 160<br>5.1.10　受保护访问 165<br>5.2　Object：所有类的超类 166<br>5.2.1　equals方法 166<br>5.2.2　相等测试与继承 167<br>5.2.3　hashCode方法 170<br>5.2.4　toString方法 172<br>5.3　泛型数组列表 178<br>5.3.1　访问数组列表元素 180<br>5.3.2　类型化与原始数组列表的兼容性 183<br>5.4　对象包装器与自动装箱 184<br>5.5　参数数量可变的方法 187<br>5.6　枚举类 188<br>5.7　反射 190<br>5.7.1　Class类 190<br>5.7.2　捕获异常 192<br>5.7.3　利用反射分析类的能力 194<br>5.7.4　在运行时使用反射分析对象 198<br>5.7.5　使用反射编写泛型数组代码 202<br>5.7.6　调用任意方法 205<br>5.8　继承的设计技巧 208<br>第6章　接口、lambda表达式与内部类 211<br>6.1　接口 211<br>6.1.1　接口概念 211<br>6.1.2　接口的特性 217<br>6.1.3　接口与抽象类 218<br>6.1.4　静态方法 218<br>6.1.5　默认方法 219<br>6.1.6　解决默认方法冲突 220<br>6.2　接口示例 222<br>6.2.1　接口与回调 222<br>6.2.2　Comparator接口 224<br>6.2.3　对象克隆 225<br>6.3　lambda表达式 231<br>6.3.1　为什么引入lambda表达式 231<br>6.3.2　lambda表达式的语法 232<br>6.3.3　函数式接口 234<br>6.3.4　方法引用 235<br>6.3.5　构造器引用 237<br>6.3.6　变量作用域 237<br>6.3.7　处理lambda表达式 239<br>6.3.8　再谈Comparator 242<br>6.4　内部类 242<br>6.4.1　使用内部类访问对象状态 244<br>6.4.2　内部类的特殊语法规则 247<br>6.4.3　内部类是否有用、必要和安全 248<br>6.4.4　局部内部类 250<br>6.4.5　由外部方法访问变量 250<br>6.4.6　匿名内部类 252<br>6.4.7　静态内部类 255<br>6.5　代理 258<br>6.5.1　何时使用代理 259<br>6.5.2　创建代理对象 259<br>6.5.3　代理类的特性 262<br>第7章　异常、断言和日志 264<br>7.1　处理错误 264<br>7.1.1　异常分类 265<br>7.1.2　声明受查异常 267<br>7.1.3　如何抛出异常 269<br>7.1.4　创建异常类 270<br>7.2　捕获异常 271<br>7.2.1　捕获异常 271<br>7.2.2　捕获多个异常 273<br>7.2.3　再次抛出异常与异常链 274<br>7.2.4　finally子句 275<br>7.2.5　带资源的try语句 278<br>7.2.6　分析堆栈轨迹元素 280<br>7.3　使用异常机制的技巧 282<br>7.4　使用断言 285<br>7.4.1　断言的概念 285<br>7.4.2　启用和禁用断言 286<br>7.4.3　使用断言完成参数检查 287<br>7.4.4　为文档假设使用断言 288<br>7.5　记录日志 289<br>7.5.1　基本日志 289<br>7.5.2　高级日志 289<br>7.5.3　修改日志管理器配置 291<br>7.5.4　本地化 292<br>7.5.5　处理器 293<br>7.5.6　过滤器 296<br>7.5.7　格式化器 296<br>7.5.8　日志记录说明 296<br>7.6　调试技巧 304<br>第8章　泛型程序设计 309<br>8.1　为什么要使用泛型程序设计 309<br>8.1.1　类型参数的好处 309<br>8.1.2　谁想成为泛型程序员 310<br>8.2　定义简单泛型类 311<br>8.3　泛型方法 313<br>8.4　类型变量的限定 314<br>8.5　泛型代码和虚拟机 316<br>8.5.1　类型擦除 316<br>8.5.2　翻译泛型表达式 317<br>8.5.3　翻译泛型方法 318<br>8.5.4　调用遗留代码 319<br>8.6　约束与局限性 320<br>8.6.1　不能用基本类型实例化类型参数 320<br>8.6.2　运行时类型查询只适用于原始类型 321<br>8.6.3　不能创建参数化类型的数组 321<br>8.6.4　Varargs警告 322<br>8.6.5　不能实例化类型变量 323<br>8.6.6　不能构造泛型数组 323<br>8.6.7　泛型类的静态上下文中类型变量无效 325<br>8.6.8　不能抛出或捕获泛型类的实例 325<br>8.6.9　可以消除对受查异常的检查 326<br>8.6.10　注意擦除后的冲突 327<br>8.7　泛型类型的继承规则 328<br>8.8　通配符类型 330<br>8.8.1　通配符概念 330<br>8.8.2　通配符的超类型限定 331<br>8.8.3　无限定通配符 334<br>8.8.4　通配符捕获 334<br>8.9　反射和泛型 337<br>8.9.1　泛型Class类 337<br>8.9.2　使用Class参数进行类型匹配 338<br>8.9.3　虚拟机中的泛型类型信息 338<br>第9章　集合 344<br>9.1　Java集合框架 344<br>9.1.1　将集合的接口与实现分离 344<br>9.1.2　Collection接口 346<br>9.1.3　迭代器 347<br>9.1.4　泛型实用方法 349<br>9.1.5　集合框架中的接口 352<br>9.2　具体的集合 353<br>9.2.1　链表 355<br>9.2.2　数组列表 362<br>9.2.3　散列集 363<br>9.2.4　树集 366<br>9.2.5　队列与双端队列 369<br>9.2.6　优先级队列 371<br>9.3　映射 372<br>9.3.1　基本映射操作 372<br>9.3.2　更新映射项 375<br>9.3.3　映射视图 376<br>9.3.4　弱散列映射 377<br>9.3.5　链接散列集与映射 378<br>9.3.6　枚举集与映射 379<br>9.3.7　标识散列映射 380<br>9.4　视图与包装器 381<br>9.4.1　轻量级集合包装器 382<br>9.4.2　子范围 382<br>9.4.3　不可修改的视图 383<br>9.4.4　同步视图 384<br>9.4.5　受查视图 384<br>9.4.6　关于可选操作的说明 385<br>9.5　算法 388<br>9.5.1　排序与混排 389<br>9.5.2　二分查找 391<br>9.5.3　简单算法 392<br>9.5.4　批操作 394<br>9.5.5　集合与数组的转换 394<br>9.5.6　编写自己的算法 395<br>9.6　遗留的集合 396<br>9.6.1　Hashtable类 397<br>9.6.2　枚举 397<br>9.6.3　属性映射 398<br>9.6.4　栈 399<br>9.6.5　位集 399<br>第10章　图形程序设计 403<br>10.1　Swing概述 403<br>10.2　创建框架 407<br>10.3　框架定位 409<br>10.3.1　框架属性 411<br>10.3.2　确定合适的框架大小 411<br>10.4　在组件中显示信息 415<br>10.5　处理2D图形 419<br>10.6　使用颜色 426<br>10.7　文本使用特殊字体 429<br>10.8　显示图像 435<br>第11章　事件处理 439<br>11.1　事件处理基础 439<br>11.1.1　实例：处理按钮点击事件 441<br>11.1.2　简洁地指定监听器 445<br>11.1.3　实例：改变观感 447<br>11.1.4　适配器类 450<br>11.2　动作 453<br>11.3　鼠标事件 459<br>11.4　AWT事件继承层次 465<br>11.4.1　语义事件和底层事件 466<br>第12章　Swing用户界面组件 469<br>12.1　Swing和模型–视图–控制器设计模式 469<br>12.1.1　设计模式 469<br>12.1.2　模型–视图–控制器模式 470<br>12.1.3　Swing按钮的模型–视图–控制器分析 473<br>12.2　布局管理概述 474<br>12.2.1　边框布局 477<br>12.2.2　网格布局 478<br>12.3　文本输入 481<br>12.3.1　文本域 482<br>12.3.2　标签和标签组件 483<br>12.3.3　密码域 484<br>12.3.4　文本区 485<br>12.3.5　滚动窗格 485<br>12.4　选择组件 488<br>12.4.1　复选框 488<br>12.4.2　单选钮 490<br>12.4.3　边框 493<br>12.4.4　组合框 496<br>12.4.5　滑动条 499<br>12.5　菜单 504<br>12.5.1　菜单创建 504<br>12.5.2　菜单项中的图标 507<br>12.5.3　复选框和单选钮菜单项 508<br>12.5.4　弹出菜单 508<br>12.5.5　快捷键和加速器 510<br>12.5.6　启用和禁用菜单项 511<br>12.5.7　工具栏 515<br>12.5.8　工具提示 516<br>12.6　复杂的布局管理 518<br>12.6.1　网格组布局 520<br>12.6.2　组布局 528<br>12.6.3　不使用布局管理器 537<br>12.6.4　定制布局管理器 537<br>12.6.5　遍历顺序 541<br>12.7　对话框 541<br>12.7.1　选项对话框 542<br>12.7.2　创建对话框 551<br>12.7.3　数据交换 554<br>12.7.4　文件对话框 559<br>12.7.5　颜色选择器 569<br>12.8　GUI程序排错 573<br>12.8.1　调试技巧 573<br>12.8.2　让AWT机器人完成工作 576<br>第13章　部署Java应用程序 580<br>13.1　JAR文件 580<br>13.1.1　创建JAR文件 580<br>13.1.2　清单文件 581<br>13.1.3　可执行JAR文件 582<br>13.1.4　资源 583<br>13.1.5　密封 585<br>13.2　应用首选项的存储 586<br>13.2.1　属性映射 586<br>13.2.2　首选项API 591<br>13.3　服务加载器 596<br>13.4　applet 598<br>13.4.1　一个简单的applet 599<br>13.4.2　applet HTML标记和属性 602<br>13.4.3　使用参数向applet传递信息 603<br>13.4.4　访问图像和音频文件 608<br>13.4.5　applet上下文 609<br>13.4.6　applet间通信 609<br>13.4.7　在浏览器中显示信息项 610<br>13.4.8　沙箱 611<br>13.4.9　签名代码 612<br>13.5　Java Web Start 614<br>13.5.1　发布Java Web Start应用 614<br>13.5.2　JNLP API 617<br>第14章　并发 624<br>14.1　什么是线程 624<br>14.1.1　使用线程给其他任务提供机会 629<br>14.2　中断线程 632<br>14.3　线程状态 635<br>14.3.1　新创建线程 635<br>14.3.2　可运行线程 635<br>14.3.3　被阻塞线程和等待线程 636<br>14.3.4　被终止的线程 636<br>14.4　线程属性 638<br>14.4.1　线程优先级 638<br>14.4.2　守护线程 639<br>14.4.3　未捕获异常处理器 639<br>14.5　同步 640<br>14.5.1　竞争条件的一个例子 641<br>14.5.2　竞争条件详解 644<br>14.5.3　锁对象 646<br>14.5.4　条件对象 648<br>14.5.5　synchronized关键字 653<br>14.5.6　同步阻塞 656<br>14.5.7　监视器概念 657<br>14.5.8　Volatile域 658<br>14.5.9　final变量 659<br>14.5.10　原子性 659<br>14.5.11　死锁 661<br>14.5.12　线程局部变量 663<br>14.5.13　锁测试与超时 665<br>14.5.14　读/写锁 666<br>14.5.15　为什么弃用stop和suspend方法 667<br>14.6　阻塞队列 668<br>14.7　线程安全的集合 673<br>14.7.1　高效的映射、集和队列 674<br>14.7.2　映射条目的原子更新 675<br>14.7.3　对并发散列映射的批操作 676<br>14.7.4　并发集视图 678<br>14.7.5　写数组的拷贝 679<br>14.7.6　并行数组算法 679<br>14.7.7　较早的线程安全集合 680<br>14.8　Callable与Future 681<br>14.9　执行器 685<br>14.9.1　线程池 685<br>14.9.2　预定执行 689<br>14.9.3　控制任务组 690<br>14.9.4　Fork-Join框架 691<br>14.9.5　可完成Future 694<br>14.10　同步器 696<br>14.10.1　信号量 696<br>14.10.2　倒计时门栓 697<br>14.10.3　障栅 697<br>14.10.4　交换器 698<br>14.10.5　同步队列 698<br>14.11　线程与Swing 698<br>14.11.1　运行耗时的任务 699<br>14.11.2　使用Swing工作线程 703<br>14.11.3　单一线程规则 708</p>
<hr>
<h2 id="effectivejava中文版"><a href="#effectivejava中文版" class="headerlink" title="effectivejava中文版"></a>effectivejava中文版</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>本书介绍了在Java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对Java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。<br>本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。</p>
<h3 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">https://book.douban.com/subject/3360807/</a></p>
<h3 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h3><p>第1章 引言<br>第2章 创建和销毁对象<br>第1条：考虑用静态工厂方法代替构造器<br>第2条：遇到多个构造器参数时要考虑用构建器<br>第3条：用私有构造器或者枚举类型强化Singleton属性<br>第4条：通过私有构造器强化不可实例化的能力<br>第5条：避免创建不必要的对象<br>第6条：消除过期的对象引用<br>第7条：避免使用终结方法<br>第3章 对于所有对象都通用的方法<br>第8条：覆盖equals时请遵守通用约定<br>第9条：覆盖equals时总要覆盖hashCode<br>第10条：始终要覆盖toString<br>第11条：谨慎地覆盖clone<br>第12条：考虑实现Comparable接口<br>第4章 类和接口<br>第13条：使类和成员的可访问性最小化<br>第14条：在公有类中使用访问方法而非公有域<br>第15条：使可变性最小化<br>第16条：复合优先于继承<br>第17条：要么为继承而设计，并提供文档说明，要么就禁止继承<br>第18条：接口优于抽象类<br>第19条：接口只用于定义类型<br>第20条：类层次优于标签类<br>第21条：用函数对象表示策略<br>第22条：优先考虑静态成员类<br>第5章 泛型<br>第23条：请不要在新代码中使用原生态类型<br>第24条：消除非受检警告<br>第25条：列表优先于数组<br>第26条：优先考虑泛型<br>第27条：优先考虑泛型方法<br>第28条：利用有限制通配符来提升API的灵活性<br>第29条：优先考虑类型安全的异构容器<br>第6章 枚举和注解<br>第30条：用enum代替int常量<br>第31条：用实例域代替序数<br>第32条：用EnumSet代替位域<br>第33条：用EnumMap代替序数索引<br>第34条：用接口模拟可伸缩的枚举<br>第35条：注解优先于命名模式<br>第36条：坚持使用Override注解<br>第37条：用标记接口定义类型<br>第7章 方法<br>第38条：检查参数的有效性<br>第39条：必要时进行保护性拷贝<br>第40条：谨慎设计方法签名<br>第41条：慎用重载<br>第42条：慎用可变参数<br>第43条：返回零长度的数组或者集合，而不是：null<br>第44条：为所有导出的API元素编写文档注释<br>第8章 通用程序设计<br>第45条：将局部变量的作用域最小化<br>第46条：for-each循环优先于传统的for循环<br>第47条：了解和使用类库<br>第48条：如果需要精确的答案，请避免使用float和double<br>第49条：基本类型优先于装箱基本类型<br>第50条：如果其他类型更适合，则尽量避免使用字符串<br>第51条：当心字符串连接的性能<br>第52条：通过接口引用对象<br>第53条：接口优先于反射机制<br>第54条：谨慎地使用本地方法<br>第55条：谨慎地进行优化<br>第56条：遵守普遍接受的命名惯例<br>第9章 异常<br>第57条：只针对异常的情况才使用异常<br>第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常<br>第59条：避免不必要地使用受检的异常<br>第60条：优先使用标准的异常<br>第61条：抛出与抽象相对应的异常<br>第62条：每个方法抛出的异常都要有文档<br>第63条：在细节消息中包含能捕获失败的信息<br>第64条：努力使失败保持原子性<br>第65条：不要忽略异常<br>第10章 并发<br>第66条：同步访问共享的可变数据<br>第67条：避免过度同步<br>第68条：executor和task优先干线程<br>第69条：并发工具优先于wait和notify<br>第70条：线程安全性的文档化<br>第71条：慎用延迟初始化<br>第72条：不要依赖于线程调度器<br>第73条：避免使用线程组<br>第11章 序列化<br>第74条：谨慎地实现Serializable接口<br>第75条：考虑使用自定义的序列化形式<br>第76条：保护性地编写readObject方法<br>第77条：对于实例控制，枚举类型优先于readResolve<br>第78条：考虑用序列化代理代替序列化实例</p>
<hr>
<h2 id="java编程思想"><a href="#java编程思想" class="headerlink" title="java编程思想"></a>java编程思想</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。<br>从本书获得的各项大奖以及来自世界各地的读者评论中，不难看出这是一本经典之作。本书的作者拥有多年教学经验，对C、C++以及Java语言都有独到、深入的见解，以通俗易懂及小而直接的示例解释了一个个晦涩抽象的概念。本书共22章，包括操作符、控制执行流程、访问权限控制、复用类、多态、接口、通过异常处理错误、字符串、泛型、数组、容器深入研究、Java I/O系统、枚举类型、并发以及图形化用户界面等内容。这些丰富的内容，包含了Java语言基础语法以及高级特性，适合各个层次的Java程序员阅读，同时也是高等院校讲授面向对象程序设计语言以及Java语言的绝佳教材和参考书。<br>第4版特点：<br>适合初学者与专业人员的经典的面向对象叙述方式，为更新的Java SE5/6增加了新的示例和章节。<br>测验框架显示程序输出。</p>
<h3 id="评价-2"><a href="#评价-2" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">https://book.douban.com/subject/2130190/</a></p>
<h3 id="目录-2"><a href="#目录-2" class="headerlink" title="目录"></a>目录</h3><p>第1章 对象导论<br>1.1 抽象过程<br>1.2 每个对象都有一个接口<br>1.3 每个对象都提供服务<br>1.4 被隐藏的具体实现<br>1.5 复用具体实现<br>1.6 继承<br>1.6.1 “是一个”（is-a）与“像是一个”（is-like-a）关系<br>1.7 伴随多态的可互换对象<br>1.8 单根继承结构<br>1.9 容器<br>1.9.1 参数化类型（范型）<br>1.10 对象的创建和生命期<br>1.11 异常处理：处理错误<br>1.12 并发编程<br>1.13 Java与Internet<br>1.13.1 Web是什么<br>1.13.2 客户端编程<br>1.13.3 服务器端编程<br>1.22 总结<br>第2章 一切都是对象<br>2.1 用引用操纵对象<br>2.2 必须由你创建所有对象<br>2.2.1 存储到什么地方<br>2.2.2 特例：基本类型<br>2.2.3 Java中的数组<br>2.3 永远不需要销毁对象<br>2.3.1 作用域<br>2.3.2 对象的作用域<br>2.4 创建新的数据类型：类<br>2.4.1 域和方法<br>2.4.2 基本成员默认值<br>2.5 方法、参数和返回值<br>2.5.1 参数列表<br>2.6 构建一个Java程序<br>2.6.1 名字可见性<br>2.6.2 运用其他构件<br>2.6.3 static 关键字<br>2.7 你的第一个Java程序<br>编译和运行<br>2.8 注释和嵌入式文档<br>2.8.1 注释文档<br>2.8.2 语法<br>2.8.3 嵌入式HTML<br>2.8.4 一些标签示例<br>2.8.5 文档示例<br>2.9 编码风格<br>2.10 总结<br>2.11 练习<br>第3章 操作符<br>3.1 更简单的打印语句<br>3.2 使用Java操作符<br>3.3 优先级<br>3.4 赋值<br>3.4.1 方法调用中的别名问题<br>3.5 算术操作符<br>3.5.1 一元加、减操作符<br>3.6 自动递增和递减<br>3.7 关系操作符<br>3.7.1 测试对象的等价性<br>3.8 逻辑操作符<br>3.8.1 短路<br>3.9 直接常量<br>3.9.1 指数记数法<br>3.10 按位操作符<br>3.11 移位操作符<br>3.12 三元操作符 if-else<br>3.13 字符串操作符 + 和 +=<br>3.14 使用操作符时常犯的错误<br>3.15 类型转换操作符<br>3.15.1 截尾和舍入<br>3.15.2提升<br>3.16 Java没有“sizeof”<br>3.17 操作符小结<br>3.18 总结<br>第4章 控制执行流程<br>4.1 true和false<br>4.2 if-else<br>4.3 迭代<br>4.3.1 do-while<br>4.3.2 for<br>4.3.3 逗号操作符<br>4.4 Foreach语法<br>4.5 return<br>4.6 break和 continue<br>4.7 臭名昭著的“goto”<br>4.8 switch<br>4.9 总结<br>第5章 初始化与清理<br>5.1 用构造器确保初始化<br>5.2 方法重载<br>5.2.1 区分重载方法<br>5.2.2 涉及基本类型的重载<br>5.2.3 以返回值区分重载方法<br>5.3 缺省构造器<br>5.4 this关键字<br>5.4.1 在构造器中调用构造器<br>5.4.2 static的含义<br>5.5 清理：终结处理和垃圾回收<br>5.5.1 finalize()的用途何在<br>5.5.2 你必须实施清理<br>5.5.3 终结条件<br>5.5.4 垃圾回收器如何工作<br>5.6 成员初始化<br>5.6.1 指定初始化<br>5.7 构造器初始化<br>5.7.1 初始化顺序<br>5.7.2. 静态数据的初始化<br>5.7.3. 显式的静态初始化<br>5.7.4. 非静态实例初始化<br>5.8 数组初始化<br>5.8.1 可变参数列表<br>5.9 枚举类型<br>5.10 总结<br>第6章 访问权限控制<br>第7章 复用类<br>第8章 多态<br>第9章 接口<br>第10章 内部类<br>第11章 持有对象<br>第12章 通过异常处理错误<br>第13章 字符串<br>第14章 类型信息<br>第15章 泛型<br>第16章 数组<br>第17章 容器深入研究<br>第18章 Java I/O系统<br>第19章 枚举类型<br>第20章 注解<br>第21章 并发<br>第22章 图形化用户界面</p>
<hr>
<h2 id="java并发编程核心方法与框架"><a href="#java并发编程核心方法与框架" class="headerlink" title="java并发编程核心方法与框架"></a>java并发编程核心方法与框架</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>本书主要介绍非常核心并常用的技术点，比如解决高并发环境下的线程间同步问题，可以使用Semaphore，CountDownLatch，CyclicBarrier以及Phaser类来解决，还要掌握线程池ThreadPoolExecutor的使用，还有线程池结合计划任务ScheduledExecutorService接口的使用，Future接口的使用，CompletionService异步任务的使用，ExecutorService工具接口的使用，Fork-Join分治编程的学习和Java技术中使用率比较高的并发集合框架。</p>
<h3 id="评价-3"><a href="#评价-3" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/26859317/" target="_blank" rel="noopener">https://book.douban.com/subject/26859317/</a></p>
<h3 id="目录-3"><a href="#目录-3" class="headerlink" title="目录"></a>目录</h3><p>第1章 Semaphore和Exchanger的使用 1<br>1.1 Semaphore的使用 2<br>1.1.1 类Semaphore的同步性 2<br>1.1.2 类Semaphore构造方法permits参数作用 4<br>1.1.3 方法acquire(int permits)参数作用及动态添加permits许可数量 5<br>1.1.4 方法acquireUninterruptibly()的使用 8<br>1.1.5 方法availablePermits()和drainPermits() 10<br>1.1.6 方法getQueueLength()和hasQueuedThreads() 12<br>1.1.7 公平与非公平信号量的测试 13<br>1.1.8 方法tryAcquire()的使用 15<br>1.1.9 方法tryAcquire(int permits)的使用 17<br>1.1.10 方法tryAcquire(long timeout, TimeUnit unit)的使用 17<br>1.1.11 方法tryAcquire(int permits, long timeout, TimeUnit unit)的使用 19<br>1.1.12 多进路-多处理-多出路实验 20<br>1.1.13 多进路-单处理-多出路实验 21<br>1.1.14 使用Semaphore创建字符串池 23<br>1.1.15 使用Semaphore实现多生产者/多消费者模式 25<br>1.2 Exchanger的使用 31<br>1.2.1 方法exchange()阻塞的特性 31<br>1.2.2 方法exchange()传递数据 32<br>1.2.3 方法exchange(V x, long timeout, TimeUnit unit)与超时 34<br>1.3 本章总结 35<br>第2章 CountDownLatch和CyclicBarrier的使用 36<br>2.1 CountDownLatch的使用 36<br>2.1.1 初步使用 37<br>2.1.2 裁判在等全部的运动员到来 38<br>2.1.3 各就各位准备比赛 39<br>2.1.4 完整的比赛流程 41<br>2.1.5 方法await(long timeout, TimeUnit unit) 44<br>2.1.6 方法getCount()的使用 46<br>2.2 CyclicBarrier的使用 46<br>2.2.1 初步使用 48<br>2.2.2 验证屏障重置性及getNumberWaiting()方法的使用 51<br>2.2.3 用CyclicBarrier类实现阶段跑步比赛 52<br>2.2.4 方法isBroken()的使用 55<br>2.2.5 方法await(long timeout, TimeUnit unit)超时出现异常的测试 57<br>2.2.6 方法getNumberWaiting()和getParties() 60<br>2.2.7 方法reset() 62<br>2.3 本章总结 64<br>第3章 Phaser的使用 65<br>3.1 Phaser的使用 66<br>3.2 类Phaser的arriveAndAwaitAdvance()方法测试1 66<br>3.3 类Phaser的arriveAndAwaitAdvance()方法测试2 68<br>3.4 类Phaser的arriveAndDeregister()方法测试 69<br>3.5 类Phaser的getPhase()和onAdvance()方法测试 70<br>3.6 类Phaser的getRegisteredParties()方法和register()测试 74<br>3.7 类Phaser的bulkRegister()方法测试 75<br>3.8 类Phaser的getArrivedParties()和getUnarrivedParties()方法测试 75<br>3.9 类Phaser的arrive()方法测试1 77<br>3.10 类Phaser的arrive ()方法测试2 78<br>3.11 类Phaser的awaitAdvance(int phase)方法测试 81<br>3.12 类Phaser的awaitAdvanceInterruptibly(int)方法测试1 83<br>3.13 类Phaser的awaitAdvanceInterruptibly(int)方法测试2 84<br>3.14 类Phaser的awaitAdvanceInterruptibly(int)方法测试3 86<br>3.15 类Phaser的awaitAdvanceInterruptibly(int,long,TimeUnit)方法测试4 87<br>3.16 类Phaser的forceTermination()和isTerminated()方法测试 89<br>3.17 控制Phaser类的运行时机 92<br>3.18 本章总结 93<br>第4章 Executor与ThreadPoolExecutor的使用 94<br>4.1 Executor接口介绍 94<br>4.2 使用Executors工厂类创建线程池 97<br>4.2.1 使用newCachedThreadPool()方法创建无界线程池 98<br>4.2.2 验证newCachedThreadPool()创建为Thread池 100<br>4.2.3 使用newCachedThreadPool (ThreadFactory)定制线程工厂 102<br>4.2.4 使用newFixedThreadPool(int)方法创建有界线程池 103<br>4.2.5 使用newFixedThreadPool(int, ThreadFactory)定制线程工厂 105<br>4.2.6 使用newSingleThreadExecutor()方法创建单一线程池 106<br>4.2.7 使用newSingleThreadExecutor(ThreadFactory)定制线程工厂 107<br>4.3 ThreadPoolExecutor的使用 107<br>4.3.1 构造方法的测试 107<br>4.3.2 方法shutdown()和shutdownNow()与返回值 119<br>4.3.3 方法isShutdown() 129<br>4.3.4 方法isTerminating ()和isTerminated () 129<br>4.3.5 方法awaitTermination(long timeout,TimeUnit unit) 131<br>4.3.6 工厂ThreadFactory+execute()+UncaughtExceptionHandler处理异常 134<br>4.3.7 方法set/getRejectedExecutionHandler() 138<br>4.3.8 方法allowsCoreThreadTimeOut()/(boolean) 140<br>4.3.9 方法prestartCoreThread()和prestartAllCoreThreads() 142<br>4.3.10 方法getCompletedTaskCount() 144<br>4.3.11 常见3种队列结合max值的因果效果 145<br>4.3.12 线程池ThreadPoolExecutor的拒绝策略 151<br>4.3.13 方法afterExecute()和beforeExecute() 157<br>4.3.14 方法remove(Runnable)的使用 159<br>4.3.15 多个get方法的测试 162<br>4.3.16 线程池ThreadPoolExecutor与Runnable执行为乱序特性 166<br>4.4 本章总结 167<br>第5章 Future和Callable的使用 168<br>5.1 Future和Callable的介绍 168<br>5.2 方法get()结合ExecutorService中的submit(Callable)的使用 168<br>5.3 方法get()结合ExecutorService中的submit(Runnable)和isDone()的使用 170<br>5.4 使用ExecutorService接口中的方法submit(Runnable, T result) 170<br>5.5 方法cancel(boolean mayInterruptIfRunning)和isCancelled()的使用 173<br>5.6 方法get(long timeout, TimeUnit unit)的使用 178<br>5.7 异常的处理 179<br>5.8 自定义拒绝策略RejectedExecutionHandler接口的使用 181<br>5.9 方法execute()与submit()的区别 182<br>5.10 验证Future的缺点 186<br>5.11 本章总结 188<br>第6章 CompletionService的使用 189<br>6.1 CompletionService介绍 189<br>6.2 使用CompletionService解决Future的缺点 190<br>6.3 使用take()方法 193<br>6.4 使用poll()方法 194<br>6.5 使用poll(long timeout, TimeUnit unit)方法 195<br>6.6 类CompletionService与异常 199<br>6.7 方法Future submit(Runnable task, V result)的测试 205<br>6.8 本章总结 207<br>第7章 接口ExecutorService的方法使用 208<br>7.1 在ThreadPoolExecutor中使用ExecutorService中的方法 208<br>7.2 方法invokeAny(Collection tasks)的使用与interrupt 209<br>7.3 方法invokeAny()与执行慢的任务异常 212<br>7.4 方法invokeAny()与执行快的任务异常 216<br>7.5 方法invokeAny()与全部异常 220<br>7.6 方法invokeAny(CollectionTasks, timeout, timeUnit)超时的测试 222<br>7.7 方法invokeAll(Collection tasks)全正确 226<br>7.8 方法invokeAll(Collection tasks)快的正确慢的异常 227<br>7.9 方法invokeAll(Collection tasks)快的异常慢的正确 230<br>7.10 方法invokeAll(Collection tasks,long timeout,TimeUnit unit)先慢后快 232<br>7.11 方法invokeAll(Collection tasks,long timeout,TimeUnit unit)先快后慢 234<br>7.12 方法invokeAll(Collection tasks,long timeout,TimeUnit unit)全慢 236<br>7.13 本章总结 238<br>第8章 计划任务ScheduledExecutorService的使用 239<br>8.1 ScheduledExecutorService的使用 240<br>8.2 ScheduledThreadPoolExecutor使用Callable延迟运行 241<br>8.3 ScheduledThreadPoolExecutor使用Runnable延迟运行 244<br>8.4 延迟运行并取得返回值 245<br>8.5 使用scheduleAtFixedRate()方法实现周期性执行 246<br>8.6 使用scheduleWithFixedDelay()方法实现周期性执行 248<br>8.7 使用getQueue()与remove()方法 250<br>8.8 方法setExecuteExistingDelayedTasksAfterShutdownPolicy()的使用 253<br>8.9 方法setContinueExistingPeriodicTasksAfterShutdownPolicy() 255<br>8.10 使用cancel(boolean)与setRemoveOnCancelPolicy()方法 257<br>8.11 本章总结 261<br>第9章 Fork-Join分治编程 262<br>9.1 Fork-Join分治编程与类结构 262<br>9.2 使用RecursiveAction让任务跑起来 264<br>9.3 使用RecursiveAction分解任务 265<br>9.4 使用RecursiveTask取得返回值与join()和get()方法的区别 266<br>9.5 使用RecursiveTask执行多个任务并打印返回值 270<br>9.6 使用RecursiveTask实现字符串累加 272<br>9.7 使用Fork-Join实现求和：实验1 273<br>9.8 使用Fork-Join实现求和：实验2 275<br>9.9 类ForkJoinPool核心方法的实验 276<br>9.9.1 方法public void execute(ForkJoinTask task)的使用 276<br>9.9.2 方法public void execute(Runnable task)的使用 278<br>9.9.3 方法public void execute(ForkJoinTask task)如何处理返回值 278<br>9.9.4 方法public ForkJoinTask submit(ForkJoinTask task)的使用 279<br>9.9.5 方法public ForkJoinTask submit(Runnable task)的使用 280<br>9.9.6 方法public ForkJoinTask submit(Callable task)的使用 281<br>9.9.7 方法public ForkJoinTask submit(Runnable task, T result)的使用 282<br>9.9.8 方法public List] invokeAll(Collection] tasks)的使用 285<br>9.9.9 方法public void shutdown()的使用 286<br>9.9.10 方法public List shutdownNow()的使用 289<br>9.9.11 方法isTerminating()和isTerminated()的使用 292<br>9.9.12 方法public boolean isShutdown()的使用 295<br>9.9.13 方法public boolean awaitTermination(long timeout, TimeUnit unit)的使用 297<br>9.9.14 方法public T invoke(ForkJoinTask task)的使用 299<br>9.9.15 监视pool池的状态 301<br>9.10 类ForkJoinTask对异常的处理 308<br>9.11 本章总结 309<br>第10章 并发集合框架 310<br>10.1 集合框架结构简要 310<br>10.1.1 接口Iterable 310<br>10.1.2 接口Collection 311<br>10.1.3 接口List 311<br>10.1.4 接口Set 312<br>10.1.5 接口Queue 312<br>10.1.6 接口Deque 312<br>10.2 非阻塞队列 313<br>10.2.1 类ConcurrentHashMap的使用 313<br>10.2.2 类ConcurrentSkipListMap的使用 322<br>10.2.3 类ConcurrentSkipListSet的使用 325<br>10.2.4 类ConcurrentLinkedQueue的使用 328<br>10.2.5 类ConcurrentLinkedDeque的使用 330<br>10.2.6 类CopyOnWriteArrayList的使用 332<br>10.2.7 类CopyOnWriteArraySet的使用 335<br>10.3 阻塞队列 337<br>10.3.1 类ArrayBlockingQueue的使用 337<br>10.3.2 类PriorityBlockingQueue的使用 338<br>10.3.3 类LinkedBlockingQueue的使用 340<br>10.3.4 类LinkedBlockingDeque的使用 341<br>10.3.5 类SynchronousQueue的使用 341<br>10.3.6 类DelayQueue的使用 344<br>10.3.7 类LinkedTransferQueue的使用 345<br>10.4 本章总结 354</p>
<hr>
<h2 id="java并发编程实战"><a href="#java并发编程实战" class="headerlink" title="java并发编程实战"></a>java并发编程实战</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>本书深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量，如何识别可并行执行的任务，如何提高单线程子系统的响应性，如何确保并发程序执行预期任务，如何提高并发代码的性能和可伸缩性等内容，最后介绍了一些高级主题，如显式锁、原子变量、非阻塞算法以及如何开发自定义的同步工具类。<br>本书适合Java程序开发人员阅读。</p>
<h3 id="评价-4"><a href="#评价-4" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">https://book.douban.com/subject/10484692/</a></p>
<h3 id="目录-4"><a href="#目录-4" class="headerlink" title="目录"></a>目录</h3><p>第1章　简介1<br>1.1　并发简史1<br>1.2　线程的优势2<br>1.2.1　发挥多处理器的强大能力2<br>1.2.2　建模的简单性3<br>1.2.3　异步事件的简化处理3<br>1.2.4　响应更灵敏的用户界面4<br>1.3　线程带来的风险4<br>1.3.1　安全性问题5<br>1.3.2　活跃性问题7<br>1.3.3　性能问题7<br>1.4　线程无处不在7<br>第一部分　基础知识<br>第2章　线程安全性11<br>2.1　什么是线程安全性13<br>2.2　原子性14<br>2.2.1　竞态条件15<br>2.2.2　示例：延迟初始化中的竞态条件16<br>2.2.3　复合操作17<br>2.3　加锁机制18<br>2.3.1　内置锁20<br>2.3.2　重入21<br>2.4　用锁来保护状态22<br>2.5　活跃性与性能23<br>第3章　对象的共享27<br>3.1　可见性27<br>3.1.1　失效数据28<br>3.1.2　非原子的64位操作29<br>3.1.3　加锁与可见性30<br>3.1.4　Volatile变量 30<br>3.2　发布与逸出32<br>3.3　线程封闭35<br>3.3.1　Ad-hoc线程封闭35<br>3.3.2　栈封闭36<br>3.3.3　ThreadLocal类37<br>3.4　不变性38<br>3.4.1　Final域39<br>3.4.2　示例：使用Volatile类型来发布不可变对象40<br>3.5　安全发布41<br>3.5.1　不正确的发布：正确的对象被破坏42<br>3.5.2 　不可变对象与初始化安全性42<br>3.5.3　安全发布的常用模式43<br>3.5.4　事实不可变对象44<br>3.5.5　可变对象44<br>3.5.6　安全地共享对象44<br>第4章　对象的组合46<br>4.1　设计线程安全的类46<br>4.1.1　收集同步需求47<br>4.1.2　依赖状态的操作48<br>4.1.3　状态的所有权48<br>4.2　实例封闭49<br>4.2.1　Java监视器模式51<br>4.2.2　示例：车辆追踪51<br>4.3　线程安全性的委托53<br>4.3.1　示例：基于委托的车辆追踪器54<br>4.3.2　独立的状态变量55<br>4.3.3　当委托失效时56<br>4.3.4　发布底层的状态变量57<br>4.3.5　示例：发布状态的车辆追踪器58<br>4.4　在现有的线程安全类中添加功能59<br>4.4.1　客户端加锁机制60<br>4.4.2　组合62<br>4.5　将同步策略文档化62<br>第5章　基础构建模块66<br>5.1　同步容器类66<br>5.1.1　同步容器类的问题66<br>5.1.2　迭代器与Concurrent-ModificationException68<br>5.1.3　隐藏迭代器69<br>5.2　并发容器70<br>5.2.1　ConcurrentHashMap71<br>5.2.2　额外的原子Map操作72<br>5.2.3　CopyOnWriteArrayList72<br>5.3　阻塞队列和生产者-消费者模式73<br>5.3.1　示例：桌面搜索75<br>5.3.2　串行线程封闭76<br>5.3.3　双端队列与工作密取77<br>5.4　阻塞方法与中断方法77<br>5.5　同步工具类78<br>5.5.1　闭锁79<br>5.5.2　FutureTask80<br>5.5.3　信号量82<br>5.5.4　栅栏83<br>5.6　构建高效且可伸缩的结果缓存85<br>第二部分　结构化并发应用程序<br>第6章　任务执行93<br>6.1　在线程中执行任务93<br>6.1.1　串行地执行任务94<br>6.1.2　显式地为任务创建线程94<br>6.1.3　无限制创建线程的不足95<br>6.2　Executor框架96<br>6.2.1　示例：基于Executor的Web服务器97<br>6.2.2　执行策略98<br>6.2.3　线程池98<br>6.2.4　Executor的生命周期99<br>6.2.5　延迟任务与周期任务101<br>6.3　找出可利用的并行性102<br>6.3.1　示例：串行的页面渲染器102<br>6.3.2　携带结果的任务Callable与Future103<br>6.3.3　示例：使用Future实现页面渲染器104<br>6.3.4　在异构任务并行化中存在的局限106<br>6.3.5　CompletionService:Executor与BlockingQueue106<br>6.3.6　示例：使用CompletionService实现页面渲染器107<br>6.3.7　为任务设置时限108<br>6.3.8　示例：旅行预定门户网站109<br>第7章　取消与关闭111<br>7.1　任务取消111<br>7.1.1　中断113<br>7.1.2　中断策略116<br>7.1.3　响应中断117<br>7.1.4　示例：计时运行118<br>7.1.5　通过Future来实现取消120<br>7.1.6　处理不可中断的阻塞121<br>7.1.7　采用newTaskFor来封装非标准的取消122<br>7.2　停止基于线程的服务124<br>7.2.1　示例：日志服务124<br>7.2.2　关闭ExecutorService127<br>7.2.3　“毒丸”对象128<br>7.2.4　示例：只执行一次的服务129<br>7.2.5　shutdownNow的局限性130<br>7.3　处理非正常的线程终止132<br>7.4　JVM关闭135<br>7.4.1　关闭钩子135<br>7.4.2　守护线程136<br>7.4.3　终结器136<br>第8章　线程池的使用138<br>8.1　在任务与执行策略之间的隐性耦合138<br>8.1.1　线程饥饿死锁139<br>8.1.2　运行时间较长的任务140<br>8.2　设置线程池的大小140<br>8.3　配置ThreadPoolExecutor141<br>8.3.1　线程的创建与销毁142<br>8.3.2　管理队列任务142<br>8.3.3　饱和策略144<br>8.3.4　线程工厂146<br>8.3.5　在调用构造函数后再定制ThreadPoolExecutor147<br>8.4　扩展 ThreadPoolExecutor148<br>8.5　递归算法的并行化149<br>第9章　图形用户界面应用程序156<br>9.1　为什么GUI是单线程的156<br>9.1.1　串行事件处理157<br>9.1.2　Swing中的线程封闭机制158<br>9.2　短时间的GUI任务160<br>9.3　长时间的GUI任务161<br>9.3.1　取消162<br>9.3.2　进度标识和完成标识163<br>9.3.3　SwingWorker165<br>9.4　共享数据模型165<br>9.4.1　线程安全的数据模型166<br>9.4.2　分解数据模型166<br>9.5　其他形式的单线程子系统167<br>第三部分　活跃性、性能与测试<br>第10章　避免活跃性危险169<br>10.1　死锁169<br>10.1.1　锁顺序死锁170<br>10.1.2　动态的锁顺序死锁171<br>10.1.3　在协作对象之间发生的死锁174<br>10.1.4　开放调用175<br>10.1.5　资源死锁177<br>10.2　死锁的避免与诊断178<br>10.2.1　支持定时的锁178<br>10.2.2　通过线程转储信息来分析死锁178<br>10.3　其他活跃性危险180<br>10.3.1　饥饿180<br>10.3.2　糟糕的响应性181<br>10.3.3　活锁181<br>第11章　性能与可伸缩性183<br>11.1　对性能的思考183<br>11.1.1　性能与可伸缩性184<br>11.1.2　评估各种性能权衡因素185<br>11.2　Amdahl定律186<br>11.2.1　示例：在各种框架中隐藏的串行部分188<br>11.2.2　Amdahl定律的应用189<br>11.3　线程引入的开销189<br>11.3.1　上下文切换190<br>11.3.2　内存同步190<br>11.3.3　阻塞192<br>11.4　减少锁的竞争192<br>11.4.1　缩小锁的范围（“快进快出”）193<br>11.4.2　减小锁的粒度195<br>11.4.3　锁分段196<br>11.4.4　避免热点域197<br>11.4.5　一些替代独占锁的方法198<br>11.4.6　监测CPU的利用率199<br>11.4.7　向对象池说“不”200<br>11.5　示例：比较Map的性能200<br>11.6　减少上下文切换的开销201<br>第12章　并发程序的测试204<br>12.1　正确性测试205<br>12.1.1　基本的单元测试206<br>12.1.2　对阻塞操作的测试207<br>12.1.3　安全性测试208<br>12.1.4　资源管理的测试212<br>12.1.5　使用回调213<br>12.1.6　产生更多的交替操作214<br>12.2　性能测试215<br>12.2.1　在PutTakeTest中增加计时功能215<br>12.2.2　多种算法的比较217<br>12.2.3　响应性衡量218<br>12.3　避免性能测试的陷阱220<br>12.3.1　垃圾回收220<br>12.3.2　动态编译220<br>12.3.3　对代码路径的不真实采样222<br>12.3.4　不真实的竞争程度222<br>12.3.5　无用代码的消除223<br>12.4　其他的测试方法224<br>12.4.1　代码审查224<br>12.4.2　静态分析工具224<br>12.4.3　面向方面的测试技术226<br>12.4.4　分析与监测工具226<br>第四部分　高级主题<br>第13章　显式锁227<br>13.1　Lock与 ReentrantLock227<br>13.1.1　轮询锁与定时锁228<br>13.1.2　可中断的锁获取操作230<br>13.1.3　非块结构的加锁231<br>13.2　性能考虑因素231<br>13.3　公平性232<br>13.4　在synchronized和ReentrantLock之间进行选择234<br>13.5　读-写锁235<br>第14章　构建自定义的同步工具238<br>14.1　状态依赖性的管理238<br>14.1.1　示例：将前提条件的失败传递给调用者240<br>14.1.2　示例：通过轮询与休眠来实现简单的阻塞241<br>14.1.3　条件队列243<br>14.2　使用条件队列244<br>14.2.1　条件谓词244<br>14.2.2　过早唤醒245<br>14.2.3　丢失的信号246<br>14.2.4　通知247<br>14.2.5　示例：阀门类248<br>14.2.6　子类的安全问题249<br>14.2.7　封装条件队列250<br>14.2.8　入口协议与出口协议250<br>14.3　显式的Condition对象251<br>14.4　Synchronizer剖析253<br>14.5　AbstractQueuedSynchronizer254<br>14.6　java.util.concurrent同步器类中的 AQS257<br>14.6.1　ReentrantLock257<br>14.6.2　Semaphore与CountDownLatch258<br>14.6.3　FutureTask259<br>14.6.4　ReentrantReadWriteLock259<br>第15章　原子变量与非阻塞同步机制261<br>15.1　锁的劣势261<br>15.2　硬件对并发的支持262<br>15.2.1　比较并交换263<br>15.2.2　非阻塞的计数器264<br>15.2.3　JVM对CAS的支持265<br>15.3　原子变量类265<br>15.3.1　原子变量是一种“更好的volatile”266<br>15.3.2　性能比较：锁与原子变量267<br>15.4　非阻塞算法270<br>15.4.1　非阻塞的栈270<br>15.4.2　非阻塞的链表272<br>15.4.3　原子的域更新器274<br>15.4.4　ABA问题275<br>第16章　Java内存模型277<br>16.1　什么是内存模型，为什么需要它277<br>16.1.1　平台的内存模型278<br>16.1.2　重排序278<br>16.1.3　Java内存模型简介280<br>16.1.4　借助同步281<br>16.2　发布283<br>16.2.1　不安全的发布283<br>16.2.2　安全的发布284<br>16.2.3　安全初始化模式284<br>16.2.4　双重检查加锁286<br>16.3　初始化过程中的安全性287</p>
<hr>
<h2 id="java面试宝典"><a href="#java面试宝典" class="headerlink" title="java面试宝典"></a>java面试宝典</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>本书是《Java程序员面试宝典》的第4版，同时也是《程序员面试宝典》的姊妹书。<br>第4版在保留前三版数据结构、字符串处理、Java程序设计等主干内容的基础上，更新了部分程序员面试题目，内容主要取材于2013年至2015年多家大公司的面试题，以反映第3版图书出版后近两年来所发生的变化，目的是帮助求职者在面试过程中更好地处理一些新问题，应对新变化。<br>本书相对上一版的变化主要有以下三点。<br>1．智力测试这一章进行了分解，扩展增加一些数字类题目、图表类题目，并修正合并了一些内容，以更好地帮助求职者应对求职过程中出现的一些细节和麻烦。<br>2．针对程序设计这一部分，我们更新了部分例题。随着互联网相关面试题的频繁出现，我们新增并更新了如下知识点：构造函数、Java接口类型、Trie树、图的遍历、动态规划算法。采用循序渐进的办法，将重要概念加以复习，完善解题思路，而不是仅仅给出答案。<br>3．针对近两年面试过程中出现的新题型，本书补充了新的章节，如操作系统的线程管理问题、哈希表问题等。与第三版相比较，更加贴近市场的变化，更加与时俱进。<br>注：以前各个版本替换下的题目将保留在作者博客，读者可以访问以下网址获取。<br><a href="http://www.cnblogs.com/programmerinterview/" target="_blank" rel="noopener">http://www.cnblogs.com/programmerinterview/</a><br>就编程而言，虽然Java和C++大相径庭，但在更加有趣的语言后面的知识是设计模式、分析模式、求职解答、算法策略、信息化……也就是说，本书追求的是程序员求职背后的一些知识，即对于技术的本质理解。所以本书虽命名为“Java程序员面试宝典”，但不仅限于对Java技术的单纯讲解。因为只有这样，求职者才能不被语言所羁绊；而对于一个企业而言，除了看中求职者对语言的熟练程度，更看重工作经验、大局观和整体架构等超脱语言的知识。<br>本书采用一种问询式的结构。这样不仅言简意赅、平易近人，而且可以容纳更多的题目，真正达到“宝典”之效用。但本书又不仅仅作为一个题库出现，对一个类型的问题不简单加以重复。本书采用循序渐进的办法：（1）将重要概念加以复习；（2）完善解题思路，而不是仅仅给出答案；（3）给出完整可靠的答案，如果是可以验证的，要给出验证的结果；（4）综合几种解题方案，给出最优解；（5）触类旁通，给出语言背后的算法本质性解释。本书的解题思路不仅能够让读者知道什么是正确的解决方案，而且让读者明白怎样能获得最 佳方案。<br>本书不同于其他Java程序书籍的主要特点如下。<br>细<br>中国软件企业的规模比较小，面试涉及的方面比较多，且比较基础，比如常会考一些编程基础性的题，而原有的面试书籍对此方面鲜有触及。本书把国内公司面试时最易考到的基础考点，放在Java基础程序设计里面，希望能切切实实解决地实际面试问题。<br>深<br>面试题通过一道题考一个专类方面的能力。说起Java，人们首先想到的是Java编程语言，然而事实上，Java是一种技术，它由四个方面组成：Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口（Java API）。从面试者的角度来讲，一个测试也许能从多方面揭示应试者的素质，至少能了解应试者所掌握类的水平。市面上流行的面试书籍在此专业性的分类方面做得不够，正因为如此，本书中追求的是程序员求职背后的一些知识：对于技术的本质理解，而不仅限于对Java技术的单纯讲解。<br>广<br>本书包括但不仅仅限于Java程序员面试试题，对求职市场面试试题做了妥善分类后，将面试对象分为软件开发人员、网络工程师、测试工程师和系统管理员。实际上，市面上流行的面试书籍仅对软件开发人员比较侧重，而忽略网络工程师和测试工程师，本书就这一方面给出了详细论断，并结合大量考题分析题目特点给出应试方案。本书在这些方面做出了改进，以适应市场需求。<br>同时本书对外企经常考到的UML及设计模式内容也做了深入的分析，从本质上诠释面试的真谛。<br>真<br>第四版在保留原书主干内容的基础上，内容非常新，可以算作面试者求职前的一份全真模拟。同时作者将求职中的细节问题（简历，招聘，签约，违约），以及笔试、面试中的感悟融入书中，给求职者以最真切的人文关怀。真情实感，娓娓道来，指引读者走上理想的工作岗位。<br>本书不是一本万能书籍，但肯定是您工作与求职的好助手、好伙伴！<br>本书主要由欧立奇编著，其他参与编写的人员有朱梅、段韬、秦晓东、李启高、马雪、胥虎军、马煜、刘洋、李富星等</p>
<h3 id="评价-5"><a href="#评价-5" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/26754536/" target="_blank" rel="noopener">https://book.douban.com/subject/26754536/</a></p>
<h3 id="目录-5"><a href="#目录-5" class="headerlink" title="目录"></a>目录</h3><p>第1部分求职过程<br>第1章应聘求职<br>1.1应聘渠道<br>1.2应聘流程<br>第2章简历书写<br>2.1书写简历注意事项<br>2.2简历模板<br>第3章求职五步曲<br>3.1笔试<br>3.2电话面试<br>3.3面试<br>3.4签约<br>3.5违约<br>第4章职业生涯发展规划<br>4.1缺乏工作经验的应届毕业生<br>4.2更换工作的程序员们<br>4.3快乐地工作<br>第2部分Java程序设计<br>第5章Java程序设计基本概念<br>5.1JVM<br>5.2i++<br>5.3类型转换<br>5.4程序结构<br>5.5运算符<br>5.6异常<br>5.7反射<br>第6章传递与引用<br>6.1传值与传引用<br>6.2静态变量与私有变量<br>6.3输入／输出流<br>6.4序列化<br>第7章循环、条件、概率<br>7.1典型递归问题<br>7.2循环与条件<br>第8章Java内存管理<br>8.1垃圾收集<br>8.2内存管理<br>8.3ClOne<br>第9章面向对象<br>9.1面向对象的基本概念<br>9.2类和对象<br>9.3嵌套类<br>9.4集合类<br>9.5构造函数和析构函数<br>9.6复制构造函数和赋值函数<br>9.7多态的概念<br>第10章继承与接口<br>10.1基础知识<br>10.2Super<br>10.3thiS<br>10.4不能继承的情况<br>10.5抽象类与接口<br>第3部分数据结构和设计模式<br>第11章数据结构基础<br>11.1堆栈<br>11.2链表、哈希表<br>11.3树、图<br>11.4排序基础知识<br>第12章字符串、数组、范型<br>12.1字符串基础问题<br>12.2StringBuffer<br>12.3正则表达式<br>12.4数字流和数组<br>12.5字符串其他问题<br>12.6范型与容器<br>第13章设计模式<br>13.1UML<br>13.2常见设计模式<br>13.3软件工程<br>……<br>第4部分操作系统、数据库、网络<br>第5部分Java开源<br>第6部分综合面试题</p>
<hr>
<h2 id="深入分析javaweb技术内幕"><a href="#深入分析javaweb技术内幕" class="headerlink" title="深入分析javaweb技术内幕"></a>深入分析javaweb技术内幕</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>《深入分析Java Web技术内幕（修订版）》新增了淘宝在无线端的应用实践，包括：CDN 动态加速、多终端化改造、 多终端Session 统一 ，以及在大流量的情况下，如何跨越性能、网络和一个地区的电力瓶颈等内容，并提供了比较完整的解决方案。<br>《深入分析Java Web技术内幕（修订版）》主要围绕Java Web 相关技术从三方面全面、深入地进行了阐述。首先介绍前端知识，即在JavaWeb 开发中涉及的一些基本知识，包括Web 请求过程、HTTP、DNS 技术和CDN 技术。其次深入介绍了Java 技术，包括I/O 技术、中文编码问题、Javac 编译原理、class 文件结构解析、ClassLoader 工作机制及JVM 的内存管理等。最后介绍了Java 服务端技术，主要包括Servlet、Session 与Cookie、Tomcat 与Jetty服务器、Spring 容器、iBatis 框架和Velocity 框架等原理介绍，并介绍了服务端的一些优化技术。<br>《深入分析Java Web技术内幕（修订版）》不仅介绍这些技术和框架的工作原理，而且结合示例来讲解，通过通俗易懂的文字和丰富、生动的配图，让读者充分并深入理解它们的内部工作原理，同时还结合了设计模式来介绍这些技术背后的架构思维。</p>
<h3 id="评价-6"><a href="#评价-6" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/25953851/" target="_blank" rel="noopener">https://book.douban.com/subject/25953851/</a></p>
<h3 id="目录-6"><a href="#目录-6" class="headerlink" title="目录"></a>目录</h3><p>第1章 深入Web请求过程    1<br>1.1 B/S网络架构概述    2<br>1.2 如何发起一个请求    4<br>1.3 HTTP解析    6<br>1.3.1 查看HTTP信息的工具    8<br>1.3.2 浏览器缓存机制    9<br>1.4 DNS域名解析    12<br>1.4.1 DNS域名解析过程    12<br>1.4.2 跟踪域名解析过程    15<br>1.4.3 清除缓存的域名    18<br>1.4.4 几种域名解析方式    19<br>1.5 CDN工作机制    20<br>1.5.1 CDN架构    20<br>1.5.2 负载均衡    21<br>1.5.3 CDN动态加速    24<br>1.6 总结    25<br>第2章 深入分析Java I/O的工作机制    26<br>2.1 Java的I/O类库的基本架构    26<br>2.1.1 基于字节的I/O操作接口    27<br>2.1.2 基于字符的I/O操作接口    28<br>2.1.3 字节与字符的转化接口    29<br>2.2 磁盘I/O工作机制    30<br>2.2.1 几种访问文件的方式    30<br>2.2.2 Java访问磁盘文件    34<br>2.2.3 Java序列化技术    35<br>2.3 网络I/O工作机制    37<br>2.3.1 TCP状态转化    38<br>2.3.2 影响网络传输的因素    40<br>2.3.3 Java Socket的工作机制    40<br>2.3.4 建立通信链路    41<br>2.3.5 数据传输    42<br>2.4 NIO的工作方式    42<br>2.4.1 BIO带来的挑战    42<br>2.4.2 NIO的工作机制    43<br>2.4.3 Buffer的工作方式    46<br>2.4.4 NIO的数据访问方式    48<br>2.5 I/O调优    50<br>2.5.1 磁盘I/O优化    50<br>2.5.2 TCP网络参数调优    51<br>2.5.3 网络I/O优化    53<br>2.6 设计模式解析之适配器模式    57<br>2.6.1 适配器模式的结构    57<br>2.6.2 Java I/O中的适配器模式    58<br>2.7 设计模式解析之装饰器模式    58<br>2.7.1 装饰器模式的结构    59<br>2.7.2 Java I/O中的装饰器模式    59<br>2.8 适配器模式与装饰器模式的区别    60<br>2.9 总结    60<br>第3章 深入分析Java Web中的中文编码问题    61<br>3.1 几种常见的编码格式    61<br>3.1.1 为什么要编码    61<br>3.1.2 如何“翻译”    62<br>3.2 在Java中需要编码的场景    64<br>3.2.1 在I/O操作中存在的编码    64<br>3.2.2 在内存操作中的编码    66<br>3.3 在Java中如何编解码    67<br>3.3.1 按照ISO-8859-1编码    69<br>3.3.2 按照GB2312编码    70<br>3.3.3 按照GBK编码    71<br>3.3.4 按照UTF-16编码    71<br>3.3.5 按照UTF-8编码    72<br>3.3.6 UTF-8编码代码片段    72<br>3.3.7 对几种编码格式的比较    74<br>3.4 在Java Web中涉及的编解码    74<br>3.4.1 URL的编解码    76<br>3.4.2 HTTP Header的编解码    79<br>3.4.3 POST表单的编解码    79<br>3.4.4 HTTP BODY的编解码    80<br>3.5 在JS中的编码问题    81<br>3.5.1 外部引入JS文件    81<br>3.5.2 JS的URL编码    82<br>3.5.3 其他需要编码的地方    84<br>3.6 常见问题分析    84<br>3.6.1 中文变成了看不懂的字符    84<br>3.6.2 一个汉字变成一个问号    85<br>3.6.3 一个汉字变成两个问号    85<br>3.6.4 一种不正常的正确编码    86<br>3.7 一种繁简转换的实现方式    87<br>3.8 总结    88<br>第4章 Javac编译原理    89<br>4.1 Javac是什么    90<br>4.2 Javac编译器的基本结构    90<br>4.3 Javac工作原理分析    92<br>4.3.1 词法分析器    93<br>4.3.2 语法分析器    100<br>4.3.3 语义分析器    105<br>4.3.4 代码生成器    115<br>4.4 设计模式解析之访问者模式    118<br>4.4.1 访问者模式的结构    119<br>4.4.2 Javac中访问者模式的实现    120<br>4.5 总结    121<br>第5章 深入class文件结构    122<br>5.1 JVM指令集简介    122<br>5.1.1 与类相关的指令    124<br>5.1.2 方法的定义    125<br>5.1.3 属性的定义    126<br>5.1.4 其他指令集    127<br>5.2 class文件头的表示形式    135<br>5.3 常量池    139<br>5.3.1 UTF8常量类型    142<br>5.3.2 Fieldref、Methodref常量类型    143<br>5.3.3 Class常量类型    143<br>5.3.4 NameAndType常量类型    144<br>5.4 类信息    144<br>5.5 Fields和Methods定义    145<br>5.6 类属性描述    149<br>5.7 Javap生成的class文件结构    150<br>5.7.1 LineNumberTable    152<br>5.7.2 LocalVariableTable    153<br>5.8 总结    155<br>第6章 深入分析ClassLoader工作机制    156<br>6.1 ClassLoader类结构分析    157<br>6.2 ClassLoader的等级加载机制    158<br>6.3 如何加载class文件    161<br>6.3.1 加载字节码到内存    161<br>6.3.2 验证与解析    163<br>6.3.3 初始化Class对象    163<br>6.4 常见加载类错误分析    163<br>6.4.1 ClassNotFoundException    163<br>6.4.2 NoClassDefFoundError    164<br>6.4.3 UnsatisfiedLinkError    165<br>6.4.4 ClassCastException    166<br>6.4.5 ExceptionInInitializerError    167<br>6.5 常用的ClassLoader分析    168<br>6.6 如何实现自己的ClassLoader    172<br>6.6.1 加载自定义路径下的class文件    172<br>6.6.2 加载自定义格式的class文件    174<br>6.7 实现类的热部署    176<br>6.8 Java应不应该动态加载类    178<br>6.9 总结    179<br>第7章 JVM体系结构与工作方式    180<br>7.1 JVM体系结构    180<br>7.1.1 何谓JVM    180<br>7.1.2 JVM体系结构详解    183<br>7.2 JVM工作机制    185<br>7.2.1 机器如何执行代码    185<br>7.2.2 JVM为何选择基于栈的架构    186<br>7.2.3 执行引擎的架构设计    187<br>7.2.4 执行引擎的执行过程    188<br>7.2.5 JVM方法调用栈    193<br>7.3 总结    197<br>第8章 JVM内存管理    198<br>8.1 物理内存与虚拟内存    199<br>8.2 内核空间与用户空间    200<br>8.3 在Java中哪些组件需要使用内存    201<br>8.3.1 Java堆    201<br>8.3.2 线程    201<br>8.3.3 类和类加载器    202<br>8.3.4 NIO    202<br>8.3.5 JNI    203<br>8.4 JVM内存结构    203<br>8.4.1 PC寄存器    204<br>8.4.2 Java栈    204<br>8.4.3 堆    205<br>8.4.4 方法区    205<br>8.4.5 运行时常量池    206<br>8.4.6 本地方法栈    206<br>8.5 JVM内存分配策略    206<br>8.5.1 通常的内存分配策略    207<br>8.5.2 Java中的内存分配详解    207<br>8.6 JVM内存回收策略    212<br>8.6.1 静态内存分配和回收    212<br>8.6.2 动态内存分配和回收    213<br>8.6.3 如何检测垃圾    213<br>8.6.4 基于分代的垃圾收集算法    215<br>8.7 内存问题分析    224<br>8.7.1 GC日志分析    224<br>8.7.2 堆快照文件分析    227<br>8.7.3 JVM Crash日志分析    227<br>8.8 实例1    233<br>8.9 实例2    235<br>8.10 实例3    237<br>8.11 总结    242<br>第9章 Servlet工作原理解析    243<br>9.1 从Servlet容器说起    243<br>9.1.1 Servlet容器的启动过程    244<br>9.1.2 Web应用的初始化工作    247<br>9.2 创建Servlet实例    249<br>9.2.1 创建Servlet对象    250<br>9.2.2 初始化Servlet    250<br>9.3 Servlet体系结构    252<br>9.4 Servlet如何工作    255<br>9.5 Servlet中的Listener    257<br>9.6 Filter如何工作    259<br>9.7 Servlet中的url-pattern    261<br>9.8 总结    262<br>第10章 深入理解Session与Cookie    263<br>10.1 理解Cookie    264<br>10.1.1 Cookie属性项    264<br>10.1.2 Cookie如何工作    265<br>10.1.3 使用Cookie的限制    268<br>10.2 理解Session    269<br>10.2.1 Session与Cookie    269<br>10.2.2 Session如何工作    270<br>10.3 Cookie安全问题    273<br>10.4 分布式Session框架    274<br>10.4.1 存在哪些问题    274<br>10.4.2 可以解决哪些问题    275<br>10.4.3 总体实现思路    275<br>10.5 Cookie压缩    280<br>10.6 表单重复提交问题    282<br>10.7 多终端Session统一    283<br>10.8 总结    285<br>第11章 Tomcat的系统架构与设计模式    286<br>11.1 Tomcat总体设计    286<br>11.1.1 Tomcat总体结构    287<br>11.1.2 Connector组件    293<br>11.1.3 Servlet容器Container    298<br>11.1.4 Tomcat中的其他组件    309<br>11.2 Tomcat中的设计模式    309<br>11.2.1 门面设计模式    309<br>11.2.2 观察者设计模式    311<br>11.2.3 命令设计模式    313<br>11.2.4 责任链设计模式    314<br>11.3 总结    316<br>第12章 Jetty的工作原理解析    317<br>12.1 Jetty的基本架构    317<br>12.1.1 Jetty基本架构简介    317<br>12.1.2 Handler的体系结构    319<br>12.2 Jetty的启动过程    320<br>12.3 接受请求    321<br>12.3.1 基于HTTP工作    321<br>12.3.2 基于AJP工作    323<br>12.3.3 基于NIO方式工作    326<br>12.4 处理请求    327<br>12.5 与JBoss集成    330<br>12.6 与Tomcat的比较    331<br>12.6.1 架构比较    331<br>12.6.2 性能比较    332<br>12.6.3 特性比较    332<br>12.7 总结    333<br>第13章 Spring框架的设计理念与设计模式分析    334<br>13.1 Spring的骨骼架构    334<br>13.1.1 Spring的设计理念    335<br>13.1.2 核心组件如何协同工作    336<br>13.2 核心组件详解    337<br>13.2.1 Bean组件    337<br>13.2.2 Context组件    339<br>13.2.3 Core组件    340<br>13.2.4 Ioc容器如何工作    342<br>13.3 Spring中AOP的特性详解    352<br>13.3.1 动态代理的实现原理    352<br>13.3.2 Spring AOP如何实现    355<br>13.4 设计模式解析之代理模式    358<br>13.4.1 代理模式原理    358<br>13.4.2 Spring中代理模式的实现    358<br>13.5 设计模式解析之策略模式    361<br>13.5.1 策略模式原理    361<br>13.5.2 Spring中策略模式的实现    362<br>13.6 总结    362<br>第14章 Spring MVC的工作机制与设计模式    364<br>14.1 Spring MVC的总体设计    364<br>14.2 Control设计    369<br>14.2.1 HandlerMapping初始化    370<br>14.2.2 HandlerAdapter初始化    372<br>14.2.3 Control的调用逻辑    373<br>14.3 Model设计    374<br>14.4 View设计    375<br>14.5 框架设计的思考    377<br>14.5.1 为什么需要框架    377<br>14.5.2 需要什么样的框架    377<br>14.5.3 框架设计原则    378<br>14.5.4 “指航灯”    378<br>14.5.5 最基本的原则    378<br>14.6 设计模式解析之模板模式    379<br>14.6.1 模板模式的结构    379<br>14.6.2 Spring MVC中的模板模式示例    379<br>14.7 总结    380<br>第15章 深入分析iBatis框架之系统架构与映射原理    381<br>15.1 iBatis框架主要的类层次结构    381<br>15.2 iBatis框架的设计策略    382<br>15.3 iBatis框架的运行原理    384<br>15.4 示例    386<br>15.5 iBatis对SQL语句的解析    388<br>15.6 数据库字段映射到Java对象    389<br>15.7 示例运行的结果    391<br>15.8 设计模式解析之简单工厂模式    391<br>15.8.1 简单工厂模式的实现原理    391<br>15.8.2 iBatis中的简单工厂模式示例    392<br>15.9 设计模式解析之工厂模式    393<br>15.9.1 工厂模式的实现原理    393<br>15.9.2 iBatis中的工厂模式示例    394<br>15.10 总结    395<br>第16章 Velocity工作原理解析    397<br>16.1 Velocity总体架构    398<br>16.2 JJTree渲染过程解析    401<br>16.2.1 #set语法    405<br>16.2.2 Velocity的方法调用    406<br>16.2.3 #if、#elseif和#else语法    409<br>16.2.4 #foreach语法    410<br>16.2.5 #parse语法    412<br>16.3 事件处理机制    413<br>16.4 常用优化技巧    416<br>16.4.1 减少树的总节点数量    416<br>16.4.2 减少渲染耗时的节点数量    416<br>16.5 与JSP比较    417<br>16.5.1 JSP渲染机制    417<br>16.5.2 Velocity与JSP    423<br>16.6 设计模式解析之合成模式    423<br>16.6.1 合成模式的结构    423<br>16.6.2 Velocity中合成模式的实现    424<br>16.7 设计模式解析之解释器模式    425<br>16.7.1 解释器模式的结构    425<br>16.7.2 Velocity中解释器模式的实现    426<br>16.8 总结    426<br>第17章 Velocity优化实践    427<br>17.1 现实存在的问题    427<br>17.2 优化的理论基础    428<br>17.2.1 程序语言的三角形结构    428<br>17.2.2 数据结构减少抽象化    429<br>17.2.3 简单的程序复杂化    429<br>17.2.4 减少翻译的代价    430<br>17.2.5 变的转化为不变的    430<br>17.3 一个高效的模板引擎实现思路    430<br>17.3.1 vm模板如何被编译    432<br>17.3.2 方法调用的无反射优化    439<br>17.3.3 将字符输出改成字节输出    442<br>17.4 优化的成果    443<br>17.4.1 将char转成byte    443<br>17.4.2 无反射执行    444<br>17.5 其他优化手段    445<br>17.6 总结    445<br>第18章 大浏览量系统的静态化架构设计    446<br>18.1 淘宝大浏览量商品详情系统简介    446<br>18.2 系统面临哪些挑战    447<br>18.3 淘宝前台系统的优化历程    449<br>18.4 大浏览量系统的静态改造    449<br>18.4.1 什么是静态化系统    449<br>18.4.2 为什么要进行静态化架构设计    450<br>18.4.3 如何改造动态系统    451<br>18.4.4 几种静态化方案的设计及选择    453<br>18.4.5 如何解决失效问题    458<br>18.4.6 服务端静态化方案的演进：CDN化    459<br>18.5 总结    462</p>
<hr>
<h2 id="java性能优化权威指南"><a href="#java性能优化权威指南" class="headerlink" title="java性能优化权威指南"></a>java性能优化权威指南</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p>Java性能优化圣经！Java之父重磅推荐！<br>本书由曾任职于Oracle/Sun的性能优化专家编写，系统而详细地讲解了性能优化的各个方面，帮助你学习Java虚拟机的基本原理、掌握一些监控Java程序性能的工具，从而快速找到程序中的性能瓶颈，并有效改善程序的运行性能。<br>Java性能优化的任何问题，都可以从本书中找到答案！</p>
<h3 id="评价-7"><a href="#评价-7" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/25828043/" target="_blank" rel="noopener">https://book.douban.com/subject/25828043/</a></p>
<h3 id="目录-7"><a href="#目录-7" class="headerlink" title="目录"></a>目录</h3><p>第1章　策略、方法和方法论　　1<br>1.1 　性能问题的现状　　1<br>1.2 　性能分析的两种方法：自顶向下和自底向上　　4<br>1.2.1 　自顶向下　　4<br>1.2.2 　自底向上　　5<br>1.3 　选择正确的平台并评估系统性能　　5<br>1.3.1 　选择正确的CPU架构　　6<br>1.3.2 　评估系统性能　　7<br>1.4 　参考资料　　7<br>第2章　操作系统性能监控　　8<br>2.1 　定义　　8<br>2.2 　CPU使用率　　9<br>2.2.1 　监控CPU使用率：Windows　　9<br>2.2.2 　监控CPU使用率：Windows typeperf　　12<br>2.2.3 　监控CPU使用率：Linux　　13<br>2.2.4 　监控CPU使用率：Solaris　　14<br>2.2.5 　命令行监控CPU使用率：Linux和Solaris　　16<br>2.3 　CPU调度程序运行队列　　19<br>2.3.1 　监控CPU调度程序运行队列：Windows　　19<br>2.3.2 　监控CPU调度程序运行队列：Solaris　　21<br>2.3.3 　监控CPU调度程序运行队列：Linux　　21<br>2.4 　内存使用率　　22<br>2.4.1 　监控内存利用率：Windows　　22<br>2.4.2 　监控内存使用率：Solaris　　23<br>2.4.3 　监控内存使用率：Linux　　24<br>2.4.4 　监控锁竞争：Solaris　　25<br>2.4.5 　监控锁竞争：Linux　　26<br>2.4.6 　监控锁竞争：Windows　　27<br>2.4.7 　隔离竞争锁　　27<br>2.4.8 　监控抢占式上下文切换　　27<br>2.4.9 　监控线程迁移　　28<br>2.5 　网络I/O使用率　　28<br>2.5.1 　监控网络I/O使用率：Solaris　　29<br>2.5.2 　监控网络I/O使用率：Linux　　30<br>2.5.3 　监控网络I/O使用率：Windows　　30<br>2.5.4 　应用性能改进的考虑　　31<br>2.6 　磁盘I/O使用率　　31<br>2.7 　其他命令行工具　　34<br>2.8 　监控CPU使用率：SPARC T系列系统　　35<br>2.9 　参考资料　　36<br>第3章　JVM概览　　38<br>3.1 　HotSpot VM的基本架构　　38<br>3.2 　HotSpot VM运行时　　40<br>3.2.1 　命令行选项　　40<br>3.2.2 　VM生命周期　　41<br>3.2.3 　VM类加载　　44<br>3.2.4 　字节码验证　　46<br>3.2.5 　类数据共享　　47<br>3.2.6 　解释器　　48<br>3.2.7 　异常处理　　49<br>3.2.8 　同步　　50<br>3.2.9 　线程管理　　51<br>3.2.10 　C++堆管理　　53<br>3.2.11 　Java本地接口　　54<br>3.2.12 　VM致命错误处理　　55<br>3.3 　HotSpot VM垃圾收集器　　56<br>3.3.1 　分代垃圾收集　　56<br>3.3.2 　新生代　　58<br>3.3.3 　快速内存分配　　60<br>3.3.4 　垃圾收集器　　60<br>3.3.5 　Serial收集器　　61<br>3.3.6 　Parallel收集器：吞吐量为先！　　62<br>3.3.7　　Mostly-Concurrent收集器：低延迟为先！　　62<br>3.3.8　　Garbage-First收集器：CMS替代者　　64<br>3.3.9 　垃圾收集器比较　　64<br>3.3.10 　应用程序对垃圾收集器的影响　　65<br>3.3.11 　简单回顾收集器历史　　65<br>3.4 　HotSpot VM JIT编译器　　65<br>3.4.1 　类型继承关系分析　　67<br>3.4.2 　编译策略　　67<br>3.4.3 　逆优化　　68<br>3.4.4 　Client JIT编译器概览　　69<br>3.4.5 　Server JIT编译器概览　　69<br>3.4.6 　静态单赋值——程序依赖图　　69<br>3.4.7 　未来增强展望　　71<br>3.5 　HotSpot VM自适应调优　　71<br>3.5.1 　Java 1.4.2的默认值　　71<br>3.5.2 　Java 5自动优化的默认值　　71<br>3.5.3 　Java 6 Update 18更新后的默认优化值　　73<br>3.5.4 　自适应Java堆调整　　74<br>3.5.5 　超越自动优化　　75<br>3.6 　参考资料　　75<br>第4章　JVM性能监控　　77<br>4.1 　定义　　77<br>4.2 　垃圾收集　　78<br>4.2.1 　重要的垃圾收集数据　　78<br>4.2.2 　垃圾收集报告　　78<br>4.2.3 　垃圾收集数据的离线分析　　86<br>4.2.4 　图形化工具　　89<br>4.3 　JIT编译器　　103<br>4.4 　类加载　　104<br>4.5 　Java应用监控　　106<br>4.6 　参考资料　　109<br>第5章　Java应用性能分析　　110<br>5.1 　术语　　111<br>5.1.1 　通用性能分析术语　　111<br>5.1.2 　Oracle Solaris Studio Performance Analyzer术语　　112<br>5.1.3 　NetBeans Profiler术语　　112<br>5.2 　Oracle Solaris Studio Performance Analyzer　　112<br>5.2.1 　支持平台　　113<br>5.2.2 　下载/安装Oracle Solaris Studio Performance Analyzer　　114<br>5.2.3 　使用Oracle Solaris Studio Performance Analyzer 抓取性能数据　　114<br>5.2.4 　查看性能数据　　118<br>5.2.5 　数据表示　　125<br>5.2.6 　过滤性能数据　　128<br>5.2.7 　命令行工具er_print　　129<br>5.3 　NetBeans Profiler　　135<br>5.3.1 　支持平台　　136<br>5.3.2 　下载安装NetBeans Profiler　　136<br>5.3.3 　开始方法分析会话　　137<br>5.3.4 　Controls子面板　　143<br>5.3.5 　Status子面板　　143<br>5.3.6 　Profiling Results子面板　　143<br>5.3.7 　Saved Snapshots子面板　　144<br>5.3.8 　View子面板　　144<br>5.3.9 　Basic Telemetry子面板　　144<br>5.3.10 　查看动态结果　　145<br>5.3.11 　对结果进行快照　　145<br>5.3.12 　启动内存分析会话　　146<br>5.3.13 　查看实时结果　　148<br>5.3.14 　对结果进行快照　　150<br>5.3.15 　定位内存泄漏　　150<br>5.3.16 　分析堆转储　　151<br>5.4 　参考资料　　152<br>第6章　Java应用性能分析技巧　　153<br>6.1 　性能优化机会　　153<br>6.2 　系统或内核态CPU使用　　154<br>6.3 　锁竞争　　161<br>6.4 　Volatile的使用　　171<br>6.5 　调整数据结构的大小　　172<br>6.5.1 　StringBuilder或StringBuffer大小的调整　　172<br>6.5.2 　Java Collection类大小调整　　175<br>6.6 　增加并行性　　179<br>6.7 　过高的CPU使用率　　181<br>6.8 　其他有用的分析提示　　182<br>6.9 　参考资料　　184<br>第7章　JVM性能调优入门　　185<br>7.1 　方法　　185<br>7.1.1 　假设条件　　187<br>7.1.2 　测试基础设施需求　　188<br>7.2 　应用程序的系统需求　　188<br>7.2.1 　可用性　　188<br>7.2.2 　可管理性　　188<br>7.2.3 　吞吐量　　189<br>7.2.4 　延迟及响应性　　189<br>7.2.5 　内存占用　　189<br>7.2.6 　启动时间　　189<br>7.3 　对系统需求分级　　190<br>7.4 　选择JVM部署模式　　190<br>7.4.1 　单JVM部署模式　　190<br>7.4.2 　多JVM部署模式　　190<br>7.4.3 　通用建议　　191<br>7.5 　选择JVM运行模式　　191<br>7.5.1 　Client模式或Server模式　　191<br>7.5.2 　32位/64位 JVM　　192<br>7.5.3 　垃圾收集器　　192<br>7.6 　垃圾收集调优基础　　193<br>7.6.1 　性能属性　　193<br>7.6.2 　原则　　193<br>7.6.3 　命令行选项及GC日志　　194<br>7.7 　确定内存占用　　197<br>7.7.1 　约束　　197<br>7.7.2 　HotSpot VM堆的布局　　197<br>7.7.3 　堆大小调优着眼点　　200<br>7.7.4 　计算活跃数据大小　　201<br>7.7.5 　初始堆空间大小配置　　202<br>7.7.6 　其他考量因素　　203<br>7.8 　调优延迟/响应性　　204<br>7.8.1 　输入　　205<br>7.8.2 　优化新生代的大小　　205<br>7.8.3 　优化老年代的大小　　207<br>7.8.4 　为CMS调优延迟　　210<br>7.8.5 　Survivor空间介绍　　212<br>7.8.6 　解析晋升阈值　　214<br>7.8.7 　监控晋升阈值　　215<br>7.8.8 　调整Survivor空间的容量　　216<br>7.8.9 　显式的垃圾收集　　222<br>7.8.10 　并发永久代垃圾收集　　223<br>7.8.11 　调优CMS停顿时间　　224<br>7.8.12 　下一步　　225<br>7.9 　应用程序吞吐量调优　　225<br>7.9.1 　CMS吞吐量调优　　225<br>7.9.2 　Throughput收集器调优　　226<br>7.9.3 　Survivor空间调优　　228<br>7.9.4 　调优并行垃圾收集线程　　231<br>7.9.5 　在NUMA系统上部署　　231<br>7.9.6 　下一步　　232<br>7.10 　极端示例　　232<br>7.11 　其他性能命令行选项　　232<br>7.11.1 　实验性（最近最大）优化　　232<br>7.11.2 　逃逸分析　　233<br>7.11.3 　偏向锁　　233<br>7.11.4 　大页面支持　　234<br>7.12 　参考资料　　236<br>第8章　Java应用的基准测试　　237<br>8.1 　基准测试所面临的挑战　　237<br>8.1.1 　基准测试的预热阶段　　238<br>8.1.2 　垃圾收集　　240<br>8.1.3 　使用Java Time接口　　240<br>8.1.4 　剔除无效代码　　241<br>8.1.5 　内联　　247<br>8.1.6 　逆优化　　251<br>8.1.7 　创建微基准测试的注意事项　　256<br>8.2 　实验设计　　257<br>8.3 　使用统计方法　　258<br>8.3.1 　计算均值　　258<br>8.3.2 　计算标准差　　258<br>8.3.3 　计算置信区间　　259<br>8.3.4 　使用假设测试　　260<br>8.3.5 　使用统计方法的注意事项　　262<br>8.4 　参考文献　　263<br>8.5 　参考资料　　263<br>第9章　多层应用的基准测试　　264<br>9.1 　基准测试难题　　264<br>9.2 　企业级应用基准测试的考量　　266<br>9.2.1 　定义被测系统　　266<br>9.2.2 　制定微基准测试　　266<br>9.2.3 　定义用户交互模型　　267<br>9.2.4 　定义性能指标　　270<br>9.2.5 　扩展基准测试　　273<br>9.2.6 　用利特尔法则验证　　274<br>9.2.7 　思考时间　　275<br>9.2.8 　扩展性分析　　278<br>9.2.9 　运行基准测试　　278<br>9.3 　应用服务器监控　　281<br>9.3.1 　GlassFish监控　　281<br>9.3.2 　监控子系统　　286<br>9.3.3 　Solaris　　287<br>9.3.4 　Linux　　288<br>9.3.5 　Windows　　288<br>9.3.6 　外部系统的性能　　289<br>9.3.7 　磁盘I/O　　292<br>9.3.8 　监控和调优资源池　　293<br>9.4 　企业级应用性能分析　　294<br>9.5 　参考资料　　295<br>第10章　Web应用的性能调优　　297<br>10.1 　Web应用的基准测试　　298<br>10.2 　Web容器的组件　　298<br>10.2.1 　HTTP连接器　　299<br>10.2.2 　Servlet引擎　　300<br>10.3 　Web容器的监控和性能调优　　300<br>10.3.1 　容器的开发和生产模式　　300<br>10.3.2 　安全管理器　　301<br>10.3.3 　JVM调优　　301<br>10.3.4 　HTTP服务和Web容器　　303<br>10.3.5 　HTTP监听器　　303<br>10.4 　最佳实践　　315<br>10.4.1 　Servlet和JSP最佳实践　　315<br>10.4.2 　内容缓存　　324<br>10.4.3 　会话持久化　　328<br>10.4.4 　HTTP服务器文件缓存　　329<br>10.5 　参考资料　　333<br>第11章　Web Service的性能　　334<br>11.1 　XML的性能　　334<br>11.1.1 　XML处理的生命周期　　335<br>11.1.2 　解析/解编组　　335<br>11.1.3 　访问　　338<br>11.1.4 　修改　　338<br>11.1.5 　序列化/编组　　339<br>11.2 　验证　　339<br>11.3 　解析外部实体　　341<br>11.4 　XML文档的局部处理　　343<br>11.5 　选择合适的API　　346<br>11.6 　JAX-WS参考实现栈　　349<br>11.7 　Web Service基准测试　　350<br>11.8 　影响Web Service性能的因素　　353<br>11.8.1 　消息大小的影响　　353<br>11.8.2 　不同Schema类型的性能特征　　355<br>11.8.3 　终端服务器的实现　　358<br>11.8.4 　处理程序的性能　　359<br>11.9 　最佳性能实践　　361<br>11.9.1 　二进制负载的处理　　361<br>11.9.2 　处理XML文档　　365<br>11.9.3 　使用MTOM发送XML文档　　365<br>11.9.4 　使用Provider接口　　368<br>11.9.5 　快速信息集　　370<br>11.9.6 　HTTP压缩　　372<br>11.9.7 　Web Service客户端的性能　　373<br>11.10 　参考资料　　374<br>第12章　Java持久化及Enterprise Java Bean的性能　　375<br>12.1 　EJB编程模型　　376<br>12.2 　Java持久化API及其参考实现　　376<br>12.3 　监控及调优EJB容器　　379<br>12.3.1 　线程池　　380<br>12.3.2 　Bean池和缓存　　382<br>12.3.3 　EclipseLink会话缓存　　385<br>12.4 　事务隔离级　　386<br>12.5 　Enterprise Java Bean的最佳实践　　387<br>12.5.1 　简要说明使用的EJB基准测试　　387<br>12.5.2 　EJB 2.1　　388<br>12.5.3 　EJB 3.0　　400<br>12.6 　Java持久化最佳实践　　403<br>12.6.1 　JPA查询语言中的查询　　403<br>12.6.2 　查询结果缓存　　405<br>12.6.3 　FetchType　　406<br>12.6.4 　连接池　　408<br>12.6.5 　批量更新　　409<br>12.6.6 　选择正确的数据库锁策略　　411<br>12.6.7 　不带事务的读取　　411<br>12.6.8 　继承　　411<br>12.7 　参考资料　　412<br>附录A 　重要的HotSpot VM选项　　413<br>附录B 　性能分析技巧示例源代码　　429<br>B.1 　锁竞争实现1　　429<br>B.2 　锁竞争实现2　　439<br>B.3 　锁竞争实现3　　449<br>B.4 　锁竞争实现4　　459<br>B.5 　锁竞争实现5　　469<br>B.6 　调整容量变化1　　481<br>B.7 　调整容量变化2　　492<br>B.8 　增加并发性的单线程实现　　504<br>B.9 　增加并发性的多线程实现　　514</p>
<hr>
<h2 id="spring入门经典"><a href="#spring入门经典" class="headerlink" title="spring入门经典"></a>spring入门经典</h2><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>开发内行企业级应用的Spring实战经验<br>Spring入门经典一书全面透彻地介绍SpringFramework；SpringFramework是Java开发领域最流行的框架，是事实上的企业级应用开发标准。本书浓墨重彩地描述实际的企业级解决方案，每一章都提供了通俗易懂的示例和动手练习，以帮助读者快速掌握必需的技能集来运用Java的全部功能并成功开发应用程序。本书涵盖POJO模型、ORM支持、SpringMVC、REST服务、SpringSecurity等基础知识，全面指导你学习整个企业级应用程序工具集的实用功能。<br>主要内容<br>◆介绍使用SpringFramework4.0(支持Java8.0和JavaEE7)进行应用程序开发的方方面面<br>◆在动手实践的引导下，重点强调如何满足现实需求并提供可操作的见解<br>◆列举了广泛示例，可将这些示例作为具体的实验参考，并深入挖掘Java的全部功能<br>◆由浅入深地讲解各项技能，从而帮助开发人员熟练掌握Spring项目中常用的工具和基础概念<br>◆详细讨论每个企业级应用程序需要关注的横向问题，比如事务管理和安全性</p>
<h3 id="评价-8"><a href="#评价-8" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/26652876/" target="_blank" rel="noopener">https://book.douban.com/subject/26652876/</a></p>
<h3 id="目录-8"><a href="#目录-8" class="headerlink" title="目录"></a>目录</h3><p>第1章 POJO编程模型、轻量级容器和控制反转 1<br>1.1 POJO编程模型 2<br>1.1.1 原来的EJB编程模型所存在的问题 2<br>1.1.2 POJO编程模型的优点 7<br>1.2 轻量级容器和控制反转 8<br>1.2.1 轻量级容器 8<br>1.2.2 控制反转 9<br>1.3 依赖注入 10<br>1.3.1 Setter注入 11<br>1.3.2 构造函数注入 11<br>1.3.3 Setter注入或构造函数注入 11<br>1.4 小结 12<br>1.5 习题 12<br>1.6 本章主要知识点 12<br>第2章 使用Spring进行依赖注入 15<br>2.1 Spring IoC容器 16<br>2.1.1 配置元数据 16<br>2.1.2 配置和使用容器 18<br>2.2 依赖注入 28<br>2.2.1 Setter注入 28<br>2.2.2 构造函数注入 29<br>2.2.3 循环依赖 32<br>2.2.4 依赖解析过程 33<br>2.2.5 重写Bean定义 34<br>2.2.6 使用depends-on特性 36<br>2.2.7 自动装配 37<br>2.2.8 Bean查找 41<br>2.3 Spring管理的Bean 42<br>2.3.1 命名Bean 42<br>2.3.2 Bean实例化方法 43<br>2.3.3 Bean作用域 46<br>2.3.4 延迟初始化 49<br>2.3.5 生命周期回调 50<br>2.3.6 Bean定义配置文件 52<br>2.3.7 环境 54<br>2.4 小结 57<br>2.5 习题 58<br>2.6 本章主要知识点 58<br>第3章 使用Spring MVC构建 Web应用程序 61<br>3.1 学习Spring MVC的功能和优点 62<br>3.2 使用Dispatcher Servlet机制 63<br>3.2.1 定义Servlet 64<br>3.2.2 访问Servlet上下文 65<br>3.3 创建第一个Spring MVC应用程序 65<br>3.4 使用注解配置Spring MVC 69<br>3.5 使用JSP处理表单 70<br>3.5.1 配置表单标签库 71<br>3.5.2 理解绑定的强大功能 72<br>3.5.3 使用表单 72<br>3.5.4 使用输入元素 73<br>3.5.5 输入日期 74<br>3.5.6 使用下拉框进行选择 74<br>3.5.7 使用单选按钮进行选择 75<br>3.5.8 使用复选框进行选择 76<br>3.5.9 添加标签 76<br>3.5.10 放置按钮 76<br>3.5.11 样式 76<br>3.6 使用注解的强大功能 81<br>3.6.1 @Controller 82<br>3.6.2 @RequestMapping 82<br>3.6.3 @ModeAttribute 82<br>3.6.4 @PathVariable 82<br>3.6.5 @ControllerAdvice 83<br>3.6.6 @InitBinder 83<br>3.6.7 @ExceptionHandler 83<br>3.7 验证用户输入 83<br>3.8 上传文件 88<br>3.9 处理异常 91<br>3.10 实现国际化(i18n) 92<br>3.11 使用主题 94<br>3.12 小结 97<br>3.13 习题 97<br>3.14 本章主要知识点 98<br>第4章 使用Spring进行JDBC数据访问 101<br>4.1 使用普通JDBC所带来的问题 102<br>4.2 引入Spring的JDBC支持 103<br>4.2.1 管理JDBC连接 103<br>4.2.2 配置和使用Spring的JDBC支持 109<br>4.3 使用Spring执行数据访问操作 112<br>4.3.1 执行查询 112<br>4.3.2 使用命名参数进行查询 115<br>4.3.3 使用In子句编写查询 116<br>4.3.4 在JdbcTemplate中使用PreparedStatements 117<br>4.3.5 插入、更新和删除记录 119<br>4.3.6 调用存储过程和存储函数 122<br>4.3.7 执行批处理操作 124<br>4.3.8 处理BLOB和CLOB对象 124<br>4.3.9 访问特定于供应商的 JDBC 方法 125<br>4.3.10 执行DDL操作 125<br>4.4 将JDBC操作模块化为Java对象 126<br>4.4.1 封装SQL查询执行 126<br>4.4.2 封装SQL DML操作 128<br>4.4.3 封装存储过程执行 129<br>4.5 异常处理和错误代码转换 130<br>4.5.1 常见的数据访问异常层次结构 130<br>4.5.2 SQLException的自动处理和转换 131<br>4.6 小结 131<br>4.7 习题 132<br>4.8 本章主要知识点 132<br>第5章 通过Spring使用JPA进行数据访问 135<br>5.1 概述ORM和JPA 136<br>5.1.1 范式不匹配 136<br>5.1.2 ORM框架的构建块 137<br>5.1.3 JPA所提供的功能 137<br>5.1.4 将对象模型映射到关系模型 137<br>5.1.5 将Java类型映射到SQL类型 142<br>5.1.6 配置和使用JPA 144<br>5.2 Spring的JPA支持 153<br>5.2.1 在Spring容器中设置JPA 153<br>5.2.2 基于纯JPA实现DAO 158<br>5.2.3 处理和转换异常 163<br>5.2.4 在Spring环境中进一步配置JPA 165<br>5.3 小结 168<br>5.4 习题 169<br>5.5 本章主要知识点 169<br>第6章 使用Spring管理事务 171<br>6.1 理解事务管理 172<br>6.2 Spring的事务抽象模型 175<br>6.2.1 本地事务与全局事务 177<br>6.2.2 PlatformTransaction Manager实现 178<br>6.2.3 Spring的抽象事务模型的优点 178<br>6.3 使用Spring进行声明式事务管理 179<br>6.3.1 将服务层与数据访问技术细节进行隔离 182<br>6.3.2 自定义默认的事务行为 184<br>6.3.3 在类级别使用@Transactional 185<br>6.3.4 理解事务传播规则 186<br>6.3.5 使用进行声明式事务管理 190<br>6.4 使用Spring进行编程式事务管理 193<br>6.5 在事务之前或者之后执行自定义逻辑 198<br>6.5.1 通知事务性操作 199<br>6.5.2 使用Transaction Synchronization执行事务后的逻辑 200<br>6.6 小结 201<br>6.7 习题 201<br>6.8 本章主要知识点 201<br>第7章 使用Spring进行测试驱动开发 203<br>7.1 配置和缓存ApplicationContext 204<br>7.1.1 在测试中使用基于XML和基于Java的上下文配置 204<br>7.1.2 使用Application ContextInitializer配置上下文 207<br>7.1.3 继承上下文配置 208<br>7.1.4 ApplicationContext缓存 210<br>7.2 注入测试夹具的依赖项 211<br>7.3 在测试中使用事务管理 213<br>7.4 测试Web应用程序 216<br>7.4.1 测试中的上下文层次结构 218<br>7.4.2 测试Request和Session作用域的Bean 219<br>7.4.3 测试Spring MVC项目 221<br>7.5 使用Mock对象以及其他用于测试的实用工具 225<br>7.5.1 Spring针对测试所提供的Mock对象 226<br>7.5.2 其他实用工具和测试注解 226<br>7.6 小结 227<br>7.7 习题 227<br>7.8 本章主要知识点 228<br>第8章 使用Spring进行面向方面编程 229<br>8.1 在Spring中开始使用AOP 230<br>8.2 熟悉通知的类型 235<br>8.2.1 Before 236<br>8.2.2 After Returning 236<br>8.2.3 After Throwing 236<br>8.2.4 After(Finally) 237<br>8.2.5 Around 238<br>8.3 定义切入点指示符 239<br>8.3.1 类型签名表达式 240<br>8.3.2 方法签名表达式 240<br>8.3.3 其他替代的切入点指示符 240<br>8.4 利用注解的强大功能 241<br>8.4.1 @Before 241<br>8.4.2 @PointCut 242<br>8.4.3 @After 243<br>8.4.4 @AfterReturning 243<br>8.4.5 @AfterThrowing 244<br>8.4.6 @Aspect 244<br>8.4.7 @Around 244<br>8.4.8 @DeclareParents 245<br>8.5 将ApectJ和Spring融合在一起 246<br>8.6 使用注解配置Spring AOP 250<br>8.7 小结 251<br>8.8 习题 251<br>8.9 本章主要知识点 252<br>第9章 Spring表达式语言 253<br>9.1 使用SpEL配置应用程序 254<br>9.2 创建一个分析器 256<br>9.3 调用方法 260<br>9.3.1 调用构造函数 262<br>9.3.2 调用静态方法 263<br>9.4 使用变量和函数 263<br>9.4.1 #root 263<br>9.4.2 #this 264<br>9.4.3 访问系统属性和环境 264<br>9.4.4 内联列表 264<br>9.4.5 注册函数 265<br>9.5 了解SpEL运算符 265<br>9.5.1 关系运算符 266<br>9.5.2 算术运算符 266<br>9.5.3 逻辑运算符 266<br>9.5.4 条件运算符 267<br>9.5.5 正则表达式运算符 268<br>9.5.6 安全导航运算符 269<br>9.5.7 集合选择和投影 269<br>9.5.8 选择集合中的第一个和最后一个元素 270<br>9.6 使用SpEL中的实用工具 271<br>9.6.1 访问Spring Bean 271<br>9.6.2 271<br>9.6.3 缓存中的表达式 272<br>9.7 小结 272<br>9.8 习题 272<br>9.9 本章主要知识点 272<br>第10章 缓存 275<br>10.1 创建第一个缓存应用程序 276<br>10.1.1 使用一个不同的名称配置缓存管理器 279<br>10.1.2 使用注解配置缓存抽象 279<br>10.2 使用缓存注解 280<br>10.2.1 @Cacheable 280<br>10.2.2 @CacheEvict 282<br>10.2.3 @CachePut 282<br>10.2.4 @Caching 282<br>10.3 实现缓存管理器 283<br>10.3.1 SimpleCacheManager 283<br>10.3.2 NoOpCacheManager 284<br>10.3.3 ConcurrentMap CacheManager 284<br>10.3.4 CompositeCache Manager 284<br>10.4 将SpEL投射到缓存中 285<br>10.5 以编程方式初始化缓存 286<br>10.6 寻找替换的缓存提供程序 288<br>10.6.1 Ehcache 288<br>10.6.2 Guava 292<br>10.6.3 Hazelcast 292<br>10.7 小结 293<br>10.8 习题 293<br>10.9 本章主要知识点 294<br>第11章 使用Spring开发REST风格的Web服务 295<br>11.1 创建第一个REST Web服务 296<br>11.2 从REST Web服务返回不同的HTTP状态码 307<br>11.3 学习一种基于注解的配置替换方法 308<br>11.4 通过XML使用REST Web服务 309<br>11.5 使用异常处理机制 312<br>11.6 对REST风格的服务进行单元测试 315<br>11.7 小结 318<br>11.8 习题 318<br>11.9 本章主要知识点 318<br>第12章 使用Spring Security保护Web应用程序的安全 321<br>12.1 为什么要使用Spring Security 322<br>12.2 Spring Security的功能 323<br>12.3 配置和使用Spring Security 324<br>12.4 理解Spring Security的基础构建基块 330<br>12.5 对用户进行身份验证 331<br>12.5.1 不成功的登录流程 331<br>12.5.2 成功的登录流程 332<br>12.5.3 匿名身份验证 333<br>12.5.4 自定义登录页面 334<br>12.5.5 注销过程 335<br>12.5.6 使用JDBC访问UserDetails 336<br>12.5.7 对密码进行加密 339<br>12.5.8 Remember-Me支持 339<br>12.5.9 用户会话管理 341<br>12.5.10 基本身份验证 342<br>12.6 授权Web请求和服务方法调用 343<br>12.6.1 授权Web请求 343<br>12.6.2 授权是如何工作的 345<br>12.6.3 基于表达式的授权 347<br>12.6.4 使用JSP安全标记 348<br>12.6.5 授权服务方法 349<br>12.7 小结 353<br>12.8 习题 354<br>12.9 本章主要知识点 354<br>第13章 Spring 4.0 357<br>13.1 跟上最新技术：Java 8和Java EE7支持 357<br>13.2 使用条件依赖项配置注入 362<br>13.3 对自动配置集合中的元素进行排序 365<br>13.4 重复的注解 367<br>13.5 引入新的注解 369<br>13.6 小结 370<br>13.7 习题 370<br>13.8 本章主要知识点 370</p>
<hr>
<h2 id="springboot实战"><a href="#springboot实战" class="headerlink" title="springboot实战"></a>springboot实战</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><p>在当今Java EE 开发中，Spring 框架是当之无愧的王者。而Spring Boot 是Spring 主推的基于“习惯优于配置”的原则，让你能够快速搭建应用的框架，从而使得Java EE 开发变得异常简单。<br>《JavaEE开发的颠覆者: Spring Boot实战》从Spring 基础、Spring MVC 基础讲起，从而无难度地引入Spring Boot 的学习。涵盖使用Spring Boot 进行Java EE 开发的绝大数应用场景，包含：Web 开发、数据访问、安全控制、批处理、异步消息、系统集成、开发与部署、应用监控、分布式系统开发等。<br>当你学完《JavaEE开发的颠覆者: Spring Boot实战》后，你将能使用Spring Boot 解决Java EE 开发中所遇到的绝大多数问题。</p>
<h3 id="评价-9"><a href="#评价-9" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/26762595/" target="_blank" rel="noopener">https://book.douban.com/subject/26762595/</a></p>
<h3 id="目录-9"><a href="#目录-9" class="headerlink" title="目录"></a>目录</h3><p>第一部分 点睛Spring 4.x<br>第1 章 Spring 基础 2<br>1.1 Spring 概述 2<br>1.1.1 Spring 的简史 2<br>1.1.2 Spring 概述 3<br>1.2 Spring 项目快速搭建 5<br>1.2.1 Maven 简介 6<br>1.2.2 Maven 安装 6<br>1.2.3 Maven 的pom.xml 7<br>1.2.4 Spring 项目的搭建 9<br>1.3 Spring 基础配置 17<br>1.3.1 依赖注入 18<br>1.3.2 Java 配置 21<br>1.3.3 AOP 24<br>第2 章 Spring 常用配置 30<br>2.1 Bean 的Scope 30<br>2.1.1 点睛 30<br>2.1.2 示例 31<br>2.2 Spring EL 和资源调用. 33<br>2.2.1 点睛 33<br>2.2.2 示例 33<br>2.3 Bean 的初始化和销毁 37<br>2.3.1 点睛 37<br>2.3.2 演示 38<br>2.4 Profile 40<br>2.4.1 点睛 40<br>2.4.2 演示 41<br>2.5 事件（Application Event） 44<br>2.5.1 点睛 44<br>2.5.2 示例 44<br>第3 章 Spring 高级话题 48<br>3.1 Spring Aware 48<br>3.1.1 点睛 48<br>3.1.2 示例 49<br>3.2 多线程 51<br>3.2.1 点睛 51<br>3.2.2 示例 51<br>3.3 计划任务 54<br>3.3.1 点睛 54<br>3.3.2 示例 54<br>3.4 条件注解@Conditional 56<br>3.4.1 点睛 56<br>3.4.2 示例 57<br>3.5 组合注解与元注解 60<br>3.5.1 点睛 60<br>3.5.2 示例 60<br>3.6 @Enable*注解的工作原理 63<br>3.6.1 第一类：直接导入配置类 63<br>3.6.2 第二类：依据条件选择配置类 64<br>3.6.3 第三类：动态注册Bean 65<br>3.7 测试 66<br>3.7.1 点睛 66<br>3.7.2 示例 67<br>第二部分 点睛Spring MVC 4.x<br>第4 章 Spring MVC 基础 72<br>4.1 Spring MVC 概述 73<br>4.2 Spring MVC 项目快速搭建 74<br>4.2.1 点睛 74<br>4.2.2 示例 74<br>4.3 Spring MVC 的常用注解 82<br>4.3.1 点睛 82<br>4.3.2 示例 83<br>4.4 Spring MVC 基本配置 87<br>4.4.1 静态资源映射 88<br>4.4.2 拦截器配置 89<br>4.4.3 @ControllerAdvice 91<br>4.4.4 其他配置 94<br>4.5 Spring MVC 的高级配置 98<br>4.5.1 文件上传配置 98<br>4.5.2 自定义HttpMessageConverter 101<br>4.5.3 服务器端推送技术 106<br>4.6 Spring MVC 的测试 113<br>4.6.1 点睛 113<br>4.6.2 示例 114<br>第三部分 实战Spring Boot<br>第5 章 Spring Boot 基础 122<br>5.1 Spring Boot 概述 122<br>5.1.1 什么是Spring Boot 122<br>5.1.2 Spring Boot 核心功能 122<br>5.1.3 Spring Boot 的优缺点 124<br>5.1.4 关于本书的Spring Boot 版本 124<br>5.2 Spring Boot 快速搭建 124<br>5.2.1 <a href="http://start.spring.io" target="_blank" rel="noopener">http://start.spring.io</a> 124<br>5.2.2 Spring Tool Suite 127<br>5.2.3 IntelliJ IDEA 129<br>5.2.4 Spring Boot CLI 132<br>5.2.5 Maven 手工构建 134<br>5.2.6 简单演示 136<br>第6 章 Spring Boot 核心 138<br>6.1 基本配置 138<br>6.1.1 入口类和@SpringBootApplication 138<br>6.1.2 关闭特定的自动配置 139<br>6.1.3 定制Banner 139<br>6.1.4 Spring Boot 的配置文件 140<br>6.1.5 starter pom 141<br>6.1.6 使用xml 配置 143<br>6.2 外部配置 143<br>6.2.1 命令行参数配置 143<br>6.2.2 常规属性配置 144<br>6.2.3 类型安全的配置（基于properties） 145<br>6.3 日志配置 148<br>6.4 Profile 配置 148<br>实战 148<br>6.5 Spring Boot 运行原理 150<br>6.5.1 运作原理 153<br>6.5.2 核心注解 154<br>6.5.3 实例分析 157<br>6.5.4 实战 160<br>第7 章 Spring Boot 的Web 开发 170<br>7.1 Spring Boot 的Web 开发支持 170<br>7.2 Thymeleaf 模板引擎 171<br>7.2.1 Thymeleaf 基础知识 171<br>7.2.2 与Spring MVC 集成 174<br>7.2.3 Spring Boot 的Thymeleaf 支持 175<br>7.2.4 实战 177<br>7.3 Web 相关配置 182<br>7.3.1 Spring Boot 提供的自动配置 182<br>7.3.2 接管Spring Boot 的Web 配置 185<br>7.3.3 注册Servlet、Filter、Listener 186<br>7.4 Tomcat 配置 187<br>7.4.1 配置Tomcat 187<br>7.4.2 代码配置Tomcat 188<br>7.4.3 替换Tomcat 190<br>7.4.4 SSL 配置 191<br>7.5 Favicon 配置 196<br>7.5.1 默认的Favicon 196<br>7.5.2 关闭Favicon 196<br>7.5.3 设置自己的Favicon 197<br>7.6 WebSocket 197<br>7.6.1 什么是WebSocket 197<br>7.6.2 Spring Boot 提供的自动配置 197<br>7.6.3 实战 198<br>7.7 基于Bootstrap 和AngularJS 的现代Web 应用 212<br>7.7.1 Bootstrap 213<br>7.7.2 AngularJS 216<br>7.7.3 实战 222<br>第8 章 Spring Boot 的数据访问 233<br>8.1 引入Docker 237<br>8.1.1 Docker 的安装 238<br>8.1.2 Docker 常用命令及参数 242<br>8.1.3 下载本书所需的Docker 镜像 247<br>8.1.4 异常处理 247<br>8.2 Spring Data JPA 248<br>8.2.1 点睛Spring Data JPA 248<br>8.2.2 Spring Boot 的支持 258<br>8.2.3 实战 260<br>8.3 Spring Data REST 284<br>8.3.1 点睛Spring Data REST 284<br>8.3.2 Spring Boot 的支持 285<br>8.3.3 实战 286<br>8.4 声名式事务 297<br>8.4.1 Spring 的事务机制 297<br>8.4.2 声名式事务 298<br>8.4.3 注解事务行为 299<br>8.4.4 类级别使用@Transactional 300<br>8.4.5 Spring Data JPA 的事务支持 300<br>8.4.6 Spring Boot 的事务支持 302<br>8.4.7 实战 303<br>8.5 数据缓存Cache 309<br>8.5.1 Spring 缓存支持 309<br>8.5.2 Spring Boot 的支持 310<br>8.5.3 实战 312<br>8.5.4 切换缓存技术 319<br>8.6 非关系型数据库NoSQL 320<br>8.6.1 MongoDB 320<br>8.6.2 Redis 329<br>第9 章 Spring Boot 企业级开发 340<br>9.1 安全控制Spring Security 340<br>9.1.1 Spring Security 快速入门 340<br>9.1.2 Spring Boot 的支持 347<br>9.1.3 实战 348<br>9.2 批处理Spring Batch 362<br>9.2.1 Spring Batch 快速入门 362<br>9.2.2 Spring Boot 的支持 370<br>9.2.3 实战 371<br>9.3 异步消息 385<br>9.3.1 企业级消息代理 386<br>9.3.2 Spring 的支持 386<br>9.3.3 Spring Boot 的支持 386<br>9.3.4 JMS 实战 387<br>9.3.5 AMQP 实战 391<br>9.4 系统集成Spring Integration 395<br>9.4.1 Spring Integration 快速入门 395<br>9.4.2 Message 395<br>9.4.3 Channel 395<br>9.4.4 Message EndPoint 398<br>9.4.5 Spring Integration Java DSL 400<br>9.4.6 实战 400<br>第10 章 Spring Boot 开发部署与测试 407<br>10.1 开发的热部署 407<br>10.1.1 模板热部署 407<br>10.1.2 Spring Loaded 407<br>10.1.3 JRebel 409<br>10.1.4 spring-boot-devtools 413<br>10.2 常规部署 413<br>10.2.1 jar 形式 413<br>10.2.2 war 形式 417<br>10.3 云部署——基于Docker 的部署 419<br>10.3.1 Dockerfile 419<br>10.3.2 安装Docker 421<br>10.3.3 项目目录及文件 421<br>10.3.4 编译镜像 423<br>10.3.5 运行 424<br>10.4 Spring Boot 的测试 424<br>10.4.1 新建Spring Boot 项目 425<br>10.4.2 业务代码 425<br>10.4.3 测试用例 427<br>10.4.4 执行测试 429<br>第11 章 应用监控 431<br>11.1 http 431<br>11.1.1 新建Spring Boot 项目 432<br>11.1.2 测试端点 432<br>11.1.3 定制端点 439<br>11.1.4 自定义端点 440<br>11.1.5 自定义HealthIndicator 444<br>11.2 JMX 447<br>11.3 SSH 449<br>11.3.1 新建Spring Boot 项目 449<br>11.3.2 运行 449<br>11.3.3 常用命令 451<br>11.3.4 定制登录用户 452<br>11.3.5 扩展命令 452<br>第12 章 分布式系统开发 456<br>12.1 微服务、原生云应用 456<br>12.2 Spring Cloud 快速入门 457<br>12.2.1 配置服务 457<br>12.2.2 服务发现 457<br>12.2.3 路由网关 457<br>12.2.4 负载均衡 457<br>12.2.5 断路器 458<br>12.3 实战 458<br>12.3.1 项目构建 458<br>12.3.2 服务发现——Discovery（Eureka Server） 459<br>12.3.3 配置——Config（Config Server） 461<br>12.3.4 服务模块——Person 服务 463<br>12.3.5 服务模块——Some 服务 466<br>12.3.6 界面模块——UI（Ribbon,Feign） 468<br>12.3.7 断路器监控——Monitor（DashBoard） 473<br>12.3.8 运行 474<br>12.4 基于Docker 部署 478<br>12.4.1 Dockerfile 编写 478<br>12.4.2 Docker Compose 480<br>12.4.3 Docker-compose.yml 编写 481<br>12.4.4 运行 483<br>附录A 485<br>A.1 基于JHipster 的代码生成 485<br>A.2 常用应用属性配置列表 488</p>
<hr>
<h2 id="springmvc学习指南"><a href="#springmvc学习指南" class="headerlink" title="springmvc学习指南"></a>springmvc学习指南</h2><h3 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h3><p>Spring MVC是Spring框架中用于Web应用快速开发的一个模块，其中的MVC是Model-View-Controller的缩写。作为当今业界最主流的Web开发框架，Spring MVC已经成为当前最热门的开发技能，同时也广泛用于桌面开发领域。<br>本书重在讲述如何通过Spring MVC来开发基于Java的Web应用。全书共计12章，分别从Spring框架、模型2和MVC模式、Spring MVC介绍、控制器、数据绑定和表单标签库、传唤器和格式化、验证器、表达式语言、JSTL、国际化、上传文件、下载文件多个角度介绍了Spring MVC。除此之外，本书还配有丰富的示例以供读者练习和参考。<br>本书是一本Spring MVC的教程，内容细致、讲解清晰，非常适合Web开发者和想要使用Spring MVC开发基于Java的Web应用的读者阅读。</p>
<h3 id="评价-10"><a href="#评价-10" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/26411275/" target="_blank" rel="noopener">https://book.douban.com/subject/26411275/</a></p>
<h3 id="目录-10"><a href="#目录-10" class="headerlink" title="目录"></a>目录</h3><p>第一章 Spring框架    1<br>1.1 XML配置文件    4<br>1.2 Spring控制反转容器的使用    4<br>1.2.3 通过构造器来创建一个bean实例    5<br>1.2.2 通过工厂方法来创建一个bean实例    5<br>1.2.3 Destroy Method的使用    6<br>1.2.4 向构造器传参    6<br>1.2.5 Setter方式依赖注入    7<br>1.2.3 构造器方式依赖注入    10<br>1.3 小结    10<br>第二章 模型2和MVC模式    11<br>2.1 模型1介绍    11<br>2.2 模型2介绍    11<br>2.3 模型2之Servlet控制器    13<br>2.3.1 Product类    15<br>2.3.2 ProductForm类    15<br>2.3.3 ControllerServlet类    16<br>2.3.4 视图    20<br>2.3.5 测试应用    22<br>2.4 解耦控制器代码    23<br>2.5 校验器    27<br>2.6 后端    32<br>2.7 本章小结    33<br>第三章 Spring MVC介绍    34<br>3.1 采用Spring MVC的好处    34<br>3.2 Spring MVC的DispatcherServlet    35<br>3.3 Controller接口    36<br>3.4 第一个Spring MVC应用    37<br>3.4.1 目录结构    37<br>3.4.2 部署描述符文件和Spring MVC配置文件    38<br>3.4.3 Controller    39<br>3.4.4 View    40<br>3.4.5 测试应用    42<br>3.5 View Resolver    43<br>3.6 本章小结    45<br>第四章 基于注解的控制器    46<br>4.1 Spring MVC注解类型    46<br>4.1.1 Controller注解类型    46<br>4.1.2 RequestMapping注解类型    47<br>4.2 编写请求处理方法    50<br>4.3 应用基于注解的控制器    52<br>4.3.1 目录结构    52<br>4.3.2 配置文件    52<br>4.3.3 Controller类    55<br>4.3.4 View    56<br>4.3.5 测试应用    57<br>4.4 应用@Autowired和@Service进行依赖注入    58<br>4.5 重定向和Flash属性    62<br>4.6 请求参数和路径变量    63<br>4.7 @ModelAttribute    66<br>4.8 小结    67<br>第五章 数据绑定和form标签库    68<br>5.1 数据绑定概览    68<br>5.2 form标签库    69<br>5.2.1 form标签    70<br>5.2.2 input标签    71<br>5.2.3 password标签    72<br>5.2.4 hidden标签    72<br>5.2.5 textarea标签    73<br>5.2.6 checkbox标签    73<br>5.2.7 radiobutton标签    74<br>5.2.8 checkboxes标签    74<br>5.2.9 radiobuttons标签    75<br>5.2.10 select标签    76<br>5.2.11 option标签    76<br>5.2.12 options标签    77<br>5.2.13 errors标签    77<br>5.3 数据绑定范例    78<br>5.3.1 目录结构    78<br>5.3.2 Domain类    78<br>5.3.3 Controller类    80<br>5.3.4 Service类    82<br>5.3.5 配置文件    85<br>5.3.6 视图    86<br>5.3.7 测试应用程序范例    88<br>5.4 小结    90<br>第六章 Converter和Formatter    91<br>6.1 converter    91<br>6.2 formatter    97<br>6.3 用registrar注册formatter    99<br>6.4 选择converter，还是formatter？    101<br>6.5 小结    101<br>第七章 验证器    102<br>7.1 验证概览    102<br>7.2 Spring验证器    103<br>7.3 ValidationUtils类    104<br>7.4 Spring的Validator范例    105<br>7.5 源文件    107<br>7.6 Controller类    107<br>7.7 测试验证器    109<br>7.8 JSR 303验证    110<br>7.9 JSR 303 Validator范例    112<br>7.10 小结    114<br>第八章 表达式语言（EL）    115<br>8.1 表达式语言（EL）的语法    115<br>8.1.1 关键字    116<br>8.1.2 [ ]和.运算符    116<br>8.1.3 取值规则    117<br>8.2 访问JavaBean    118<br>8.3 EL隐式对象    118<br>8.3.1 pageContext    119<br>8.4 使用其他EL运算符    122<br>8.4.1 算术运算符    122<br>8.3.3 关系运算符    123<br>8.4.2 逻辑运算符    123<br>8.4.3 关系运算符    123<br>8.4.4 empty运算符    124<br>8.5 如何在JSP 2.0及其更高版本中配置EL    124<br>8.5.1 实现免脚本的JSP页面    124<br>8.5.2 禁用EL计算    125<br>8.6 小结    126<br>第九章 JSTL    127<br>9.1 下载JSTL    127<br>9.2 JSTL库    127<br>9.3 一般行为    129<br>9.3.1 out标签    129<br>9.3.2 set标签    130<br>9.3.3 remove标签    132<br>9.4 条件行为    132<br>9.4.1 if标签    133<br>9.4.2 choose、when和otherwise标签    134<br>9.5 遍历行为    135<br>9.5.1 forEach标签    135<br>9.5.2 forTokens标签    143<br>9.6 与URL相关的行为    144<br>9.6.1 url标签    144<br>9.6.2 redirect标签    146<br>9.7 格式化行为    146<br>9.7.1 formatNumber标签    146<br>9.7.2 formatDate标签    149<br>9.7.3 timeZone标签    150<br>9.7.4 setTimeZone标签    152<br>9.7.5 parseNumber    152<br>9.7.6 parseDate标签    153<br>9.8 函数    155<br>9.8.1 contains函数    155<br>9.8.2 containsIgnoreCase函数    155<br>9.8.3 endsWith函数    156<br>9.8.4 escapeXml函数    156<br>9.8.5 indexOf函数    156<br>9.8.6 join函数    156<br>9.8.7 length函数    157<br>9.8.8 replace函数    157<br>9.8.9 split函数    157<br>9.8.10 startsWith函数    158<br>9.8.11 substring函数    158<br>9.8.12 substringAfter函数    158<br>9.8.13 substringBefore函数    158<br>9.8.14 toLowerCase函数    159<br>9.8.15 toUpperCase函数    159<br>9.8.16 trim函数    159<br>9.9 小结    159<br>第十章 国际化    160<br>10.1 语言区域    161<br>10.2 国际化Spring MVC应用程序    163<br>10.3 将文本元件隔离成属性文件    163<br>10.4 读取属性文件    165<br>10.5 告诉Spring MVC要使用哪个语言区域    166<br>10.6 使用message标签    167<br>10.7 范例    167<br>10.8 小结    173<br>第十一章 上传文件    174<br>11.1 客户端编程    174<br>11.2 MultipartFile接口    175<br>11.3 用Commons FileUpload上传文件    176<br>11.4 Domain类    177<br>11.5 控制器    178<br>11.6 配置文件    179<br>11.7 JSP页面    181<br>11.8 应用程序的测试    183<br>11.9 用Servlet 3及其更高版本上传文件    184<br>11.10 客户端上传    188<br>11.11 小结    196<br>第十二章 下载文件    197<br>12.1 文件下载概览    197<br>12.2 范例1：隐藏资源    198<br>12.3 范例2：防止交叉引用    202<br>12.4 小结    206<br>附录A Tomcat    207<br>附录B servlet    211<br>附录C JavaServer Pages    236<br>附录D 部署描述符    258</p>
<hr>
<h2 id="maven实战"><a href="#maven实战" class="headerlink" title="maven实战"></a>maven实战</h2><h3 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h3><p>你是否早已厌倦了日复一日的手工构建工作？你是否对各个项目风格迥异的构建系统感到恐惧？Maven——这一Java社区事实标准的项目管理工具，能帮你从琐碎的手工劳动中解脱出来，帮你规范整个组织的构建系统。不仅如此，它还有依赖管理、自动生成项目站点等超酷的特性，已经有无数的开源项目使用它来构建项目并促进团队交流，每天都有数以万计的开发者在访问中央仓库以获取他们需要的依赖。<br>本书内容全面而系统，Maven的原理、使用方法和高级应用尽含其中；注重实战是本书的另一个特点，不仅在各个知识点都辅有大量的小案例，而且还有一个综合性的案例贯穿全书。如果你想使用Maven，或正在使用Maven，本书将给你绝佳的指导。<br>本书讨论专区：<a href="http://www.juvenxu.com/mvn-in-action/" target="_blank" rel="noopener">http://www.juvenxu.com/mvn-in-action/</a></p>
<h3 id="评价-11"><a href="#评价-11" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/5345682/" target="_blank" rel="noopener">https://book.douban.com/subject/5345682/</a></p>
<h3 id="目录-11"><a href="#目录-11" class="headerlink" title="目录"></a>目录</h3><ol>
<li>Maven简介</li>
<li>1 何为Maven</li>
<li>2 为什么需要Maven</li>
<li>3 Maven与极限编程</li>
<li>4 被误解的Maven</li>
<li>Maven安装</li>
<li>1 在Windows上安装Maven</li>
<li>2 在基于Unix的系统上安装Maven</li>
<li>3 安装目录分析</li>
<li>4 设置HTTP代理</li>
<li>5 安装m2eclipse</li>
<li>6 安装NetBeans Maven插件</li>
<li>7 Maven安装最佳实践</li>
<li>Hello World</li>
<li>1 编写POM</li>
<li>2 编写主代码</li>
<li>3 编写测试代码</li>
<li>4 打包和运行</li>
<li>5 使用Archetype生成项目骨架</li>
<li>6 m2eclipse简单使用</li>
<li>7 NetBeans Maven插件简单使用</li>
<li>背景案例</li>
<li>1 简单的账户注册服务</li>
<li>2 需求阐述</li>
<li>3 简要设计</li>
<li>坐标和依赖</li>
<li>1 何为Maven坐标</li>
<li>2 坐标详解</li>
<li>3 account-email</li>
<li>4 依赖的配置</li>
<li>5 依赖范围</li>
<li>6 传递性依赖</li>
<li>7 依赖调解</li>
<li>8 可选依赖</li>
<li>9 最佳实践</li>
<li>仓库</li>
<li>1 何为Maven仓库</li>
<li>2 仓库的布局</li>
<li>3 仓库的分类</li>
<li>4 远程仓库的配置</li>
<li>5 快照版本</li>
<li>6 从仓库解析依赖的机制</li>
<li>7 镜像</li>
<li>8 仓库搜索服务</li>
<li>生命周期和插件</li>
<li>1 何为生命周期</li>
<li>2 生命周期详解</li>
<li>3 插件目标</li>
<li>4 插件绑定</li>
<li>5 插件配置</li>
<li>6 获取插件信息</li>
<li>7 从命令行调用插件</li>
<li>8 插件解析机制</li>
<li>聚合与继承</li>
<li>1 account-persist</li>
<li>2 聚合</li>
<li>3 继承</li>
<li>4 聚合与继承的关系</li>
<li>5 约定优于配置</li>
<li>6 反应堆</li>
<li>使用 Nexus 创建私服</li>
<li>1 Nexus简介</li>
<li>2 安装Nexus</li>
<li>3 Nexus的仓库与仓库组</li>
<li>4 Nexus的索引与构件搜索</li>
<li>5 配置Maven从Nexus下载构件</li>
<li>6 部署构件至Nexus</li>
<li>7 Nexus的权限管理</li>
<li>8 Nexus的调度任务</li>
<li>9 其他私服软件</li>
<li>使用 Maven 进行测试</li>
<li>1 account-captcha</li>
<li>2 maven-surefire-plugin简介</li>
<li>3 跳过测试</li>
<li>4 动态指定要运行的测试用例</li>
<li>5 包含与排除测试用例</li>
<li>6 测试报告</li>
<li>7 运行TestNG测试</li>
<li>8 重用测试代码</li>
<li>使用 Hudson 进行持续集成</li>
<li>1 持续集成的作用、过程和优势</li>
<li>2 Hudson简介</li>
<li>3 安装Hudson</li>
<li>4 准备Subversion仓库</li>
<li>5 Hudson的基本系统设置</li>
<li>6 创建Hudson任务</li>
<li>7 监视Hudson任务状态</li>
<li>8 Hudson用户管理</li>
<li>9 邮件反馈</li>
<li>10 Hudson工作目录</li>
<li>构建 Web 应用</li>
<li>1 Web项目的基本结构</li>
<li>2 account-service</li>
<li>3 account-web</li>
<li>4 使用jetty-maven-plugin进行测试</li>
<li>5 使用Cargo实现自动化部署</li>
<li>版本管理</li>
<li>1 何为版本管理</li>
<li>2 Maven的版本号定义约定</li>
<li>3 主干、标签与分支</li>
<li>4 自动化版本发布</li>
<li>5 自动化创建分支</li>
<li>6 GPG签名</li>
<li>灵活的构建</li>
<li>1 Maven属性</li>
<li>2 构建环境的差异</li>
<li>3 资源过滤</li>
<li>4 Maven Profile</li>
<li>5 Web资源过滤</li>
<li>6 在Profile中激活集成测试</li>
<li>生成项目站点</li>
<li>1 最简单的站点</li>
<li>2 丰富项目信息</li>
<li>3 项目报告插件</li>
<li>4 自定义站点外观</li>
<li>5 创建自定义页面</li>
<li>6 国际化</li>
<li>7 部署站点</li>
<li>m2eclipse</li>
<li>1 m2eclipse简介</li>
<li>2 安装m2eclipse</li>
<li>3 新建Maven项目</li>
<li>4 导入Maven项目</li>
<li>5 执行mvn命令</li>
<li>6 访问Maven仓库</li>
<li>7 管理项目依赖</li>
<li>8 其它实用功能</li>
<li>编写 Maven 插件</li>
<li>1 编写Maven插件的一般步骤</li>
<li>2 代码行统计Maven插件</li>
<li>3 Mojo标注</li>
<li>4 Mojo参数</li>
<li>5 错误处理和日志</li>
<li>6 测试Maven插件</li>
<li>Archetype</li>
<li>1 Archetype使用再叙</li>
<li>2 编写Archetype</li>
<li>3 Archetype Catalog</li>
</ol>
<hr>
<h2 id="eclipse精粹"><a href="#eclipse精粹" class="headerlink" title="eclipse精粹"></a>eclipse精粹</h2><h3 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a>简介</h3><p>在利用当今最强大的Java开发环境Eclipse时，你所需了解的东西在本书中都可以找到。本书重点介绍了如何用Eclipse提高程序员的生产力。作者在本书中介绍使用Eclipse的最佳经验，全面展示了如何把Eclipse集成到敏捷开发处理中。无论是构造企业系统，还是构造Eclipse插件或其他东西，本书都有助于你更快地编写出更好的代码。<br>本书主要介绍当前最流行的Java开发环境Eclipse的特性与使用精要。全书共分两部分：第一部分说明了如何定制Eclipse工作空间、项目、视图和窗口，以便获得最高的效率，此外还说明了如何利用Eclipse的快速开发、导航和调试特性，最大化程序员的生产力，最优化代码的质量。第二部分完全侧重于敏捷开发的介绍，展示了如何用Eclipse快速实现小组所有权、重构、持续测试、持续集成以及其他敏捷开发操作。<br>本书可供应用开发人员参考，也适合广大程序设计爱好者自学。</p>
<h3 id="评价-12"><a href="#评价-12" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/1683909/" target="_blank" rel="noopener">https://book.douban.com/subject/1683909/</a></p>
<h3 id="目录-12"><a href="#目录-12" class="headerlink" title="目录"></a>目录</h3><p>暂无</p>
<hr>
<h2 id="tomcat权威指南"><a href="#tomcat权威指南" class="headerlink" title="tomcat权威指南"></a>tomcat权威指南</h2><h3 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h3><p>本书是一本万能工具，其主题涵盖了Apache Tomcat这一广受欢迎的开源servlet、JSP容器和高性能的web server。《Tomcat权威指南》对管理员和web站点管理员而言，具有较强的参考价值；对在开发或产品中要使用Tomcat作为web应用程序服务器的开发者而言，这是一本有用的指南书；对Tomcat感兴趣的人而言，这是一本优秀的介绍工具。<br>本书是最新Tomcat版本的更新，这是第二版，提供了关于servlet容器安装、配置、维护和安全防护的完整指南。实际上，鉴于具有如此多的最新信息，这本书本质上是一本新书，而不是原书的简单翻版。通过本书，您会了解到在所有主要操作系统（Windows、Linux、OSX、S01aris和FreeBSD）上使用Tomcat的详细信息，包括关于Tomcat配置文件以及部署和运行web应用程序的交互建议的详细信息。</p>
<h3 id="评价-13"><a href="#评价-13" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/4098318/" target="_blank" rel="noopener">https://book.douban.com/subject/4098318/</a></p>
<h3 id="目录-13"><a href="#目录-13" class="headerlink" title="目录"></a>目录</h3><p>第1章 Tomcat的开幕式<br>安装Tomcat<br>Tomcat的启动、停止及重启<br>自动启动<br>安装后的测试<br>Tomcat从何而来？<br>第2章 配置Tomcat<br>使用Apache Web服务器<br>重定向Web应用程序的目录<br>从8080改变端口号<br>Java VM配置<br>变换JSP编译器<br>管理领域、角色及用户<br>控制会话<br>访问JNDI与JDBC的资源<br>Servlet自动重载<br>定制用户目录<br>Tomcat应用程序示例<br>公共网关接口（CGI)<br>Tbmcat Admin webapp<br>第3章 在Tomcat中部署Servlet与JSP Web应用程序<br>Web应用程序的布局<br>部署解包的Web应用程序目录<br>部署WAR文件<br>热部署<br>使用WAR文件<br>Manager Web应用程序<br>Apache Ant自动化部署<br>Symbolic Links<br>第4章 Tomcat的性能调校<br>测量Web服务器的性能<br>外部调校<br>内部调校<br>容量规划<br>额外的资源<br>第5章 与Apache Web服务器的整合<br>整合的优缺点<br>安装Apache httpd<br>Apache与Tomcat的整合<br>Tomcat在APR连接器上提供HTTP服务<br>第6章 Tomcat安全防护<br>系统安全防护<br>多台服务器的安全防护模式<br>使用SecurityManager<br>授予文件权限<br>设置Tomcat chroot Jail<br>过滤黑客攻击<br>用SSL加强Tomcat的安全防护性能<br>第7章 配置<br>server.xml<br>web.xml<br>tomcat-users.xml<br>catalina.policy<br>catalina.properties<br>context.xml<br>第8章 调试与疑难排解<br>解读日志文件<br>猎寻错误<br>URL与HTTP会话<br>用RequestDumper Valve来调试<br>无法停止Tomcat的疑难排解<br>第9章 从源代码组建Tomcat<br>安装Apache Ant<br>获取资源<br>下载支持库<br>组建Tomcat<br>第10章 Tomcat集群<br>集群术语<br>HTTP请求的通信序列<br>分布式JAVA Servlet Container<br>Tomcat 6集群实现<br>JDBC请求分布与故障复原<br>其他资源<br>第11章 闭幕式<br>补充资源<br>社区<br>附录A 安装Java<br>附录B jbchroot.c<br>附录C BadlnputValve.java<br>附录D BadlnputFiter.java<br>附录E RPM包文件</p>
<hr>
<h2 id="headFirst设计模式"><a href="#headFirst设计模式" class="headerlink" title="headFirst设计模式"></a>headFirst设计模式</h2><h3 id="简介-14"><a href="#简介-14" class="headerlink" title="简介"></a>简介</h3><p>《HeadFirst设计模式》(中文版)共有14章，每章都介绍了几个设计模式，完整地涵盖了四人组版本全部23个设计模式。前言先介绍这本书的用法；第1章到第11章陆续介绍的设计模式为Strategy、Observer、Decorator、Abstract Factory、Factory Method、Singleton，Command、Adapter、Facade、TemplateMethod、Iterator、Composite、State、Proxy。最后三章比较特别。第12章介绍如何将两个以上的设计模式结合起来成为新的设计模式(例如著名的MVC模式)，作者称其为复合设计模式(这是作者自创的名称，并非四人组的标准名词)，第13章介绍如何进一步学习设计模式，如何发觉新的设计模式等主题，至于第14章则很快地浏览尚未介绍的设计模式，包括Bridge、Builder、Chain of Responsibility、Flyweight、Interpreter、Mediator、Memento、Prototype，Visitor。第1章还介绍了四个○○基本概念(抽象、封装、继承、多态)，而第1章到第9章也陆续介绍了九个○○原则(Principle)。千万不要轻视这些○○原则，因为每个设计模式背后都包含了几个○○原则的概念。很多时候，在设计时有两难的情况，这时候我们必须回归到○○原则，以方便判断取舍。可以这么说：○○原则是我们的目标，而设计模式是我们的做法。</p>
<h3 id="评价-14"><a href="#评价-14" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">https://book.douban.com/subject/2243615/</a></p>
<h3 id="目录-14"><a href="#目录-14" class="headerlink" title="目录"></a>目录</h3><p>谁适合读这本书?<br>我们知道你的大脑在想什么<br>元认知<br>让你的大脑就范<br>技术审校<br>致谢<br>1　欢迎来到设计模式世界：设计模式入门<br>模拟鸭子应用<br>Joe想到继承<br>利用接口如何？<br>软件开发的不变真理<br>分开变化和不变部分<br>设计鸭子的行为<br>测试鸭子的代码<br>动态地设置行为<br>封装行为的大局观<br>“有一个”比“是一个”更好<br>策略模式<br>共享模式词汇的威力<br>我如何使用设计模式？<br>设计箱内的工具<br>习题解答<br>2　让你的对象知悉现况<br>气象观测站<br>认识观察者模式<br>出版者＋订阅者＝观罕者模式<br>五分钟短剧：观察主题<br>定义观察者模式<br>松耦合的威力<br>设计气象站<br>实现气象站<br>使用Java内建的观察者模式<br>java.util.Observable的黑暗面<br>设计箱内的工具<br>习题解答<br>……<br>3　装饰者模式：装饰对象<br>4　工厂模式：烘烤OO的精华<br>5　单件模式：独一无二的对象<br>6　命令模式：封装调用<br>7　适配器模式与外观模式：随遇而安<br>8　模板方法模式：封装算法<br>9　送代器与组合模式：管理良好的集合<br>10　状态模式：事物的状态<br>11　代理模式：控制对象访问<br>12　复合模式：模式中的模式<br>13　与设计模式相处：真实世界中的模式<br>A　附录A：剩下的模式</p>
<hr>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="简介-15"><a href="#简介-15" class="headerlink" title="简介"></a>简介</h3><p>《设计模式》系统介绍了设计模式。全书共分27章，内容包括统一建模语言基础知识、面向对象设计原则、设计模式概述、简单工厂模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式、单例模式、适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式、职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式和访问者模式。《设计模式》结合大量实例来学习GoF设计模式，针对每一个设计模式均提供了一或两个实例，并对每一个模式进行了详尽的讲解，每一章最后均配有一定量的习题。《设计模式》既可作为高等院校计算机相关专业本科生和研究生设计模式、软件体系结构等课程教材，也可作为各软件培训机构培训教材及全国计算机技术与软件专业技术资格（水平）考试辅导教材，还可作为软件架构师、软件工程师等开发人员的参考用书。</p>
<h3 id="评价-15"><a href="#评价-15" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/6902815/" target="_blank" rel="noopener">https://book.douban.com/subject/6902815/</a></p>
<h3 id="目录-15"><a href="#目录-15" class="headerlink" title="目录"></a>目录</h3><p>第1章 统一建模语言基础知识<br>1.1 uml简介<br>1.2 类图<br>1.3 顺序图<br>1.4 状态图<br>1.5 本章小结<br>思考与练习<br>第2章 面向对象设计原则<br>2.1 面向对象设计原则概述<br>2.2 单一职责原则<br>2.3 开闭原则<br>2.4 里氏代换原则<br>2.5 依赖倒转原则<br>2.6 接口隔离原则<br>2.7 合成复用原则<br>2.8 迪米特法则<br>2.9 本章小结<br>思考与练习<br>第3章 设计模式概述<br>3.1 设计模式的诞生与发展<br>3.2 设计模式的定义与分类<br>3.3 gof设计模式简介<br>3.4 设计模式的优点<br>3.5 本章小结<br>思考与练习<br>第4章 简单工厂模式<br>4.1 创建型模式<br>4.2 简单工厂模式动机与定义<br>4.3 简单工厂模式结构与分析<br>4.4 简单工厂模式实例与解析<br>4.5 简单工厂模式效果与应用<br>4.6 简单工厂模式扩展<br>4.7 本章小结<br>思考与练习<br>第5章 工厂方法模式<br>5.1 工厂方法模式动机与定义<br>5.2 工厂方法模式结构与分析<br>5.3 工厂方法模式实例与解析<br>5.4 工厂方法模式效果与应用<br>5.5 工厂方法模式扩展<br>5.6 本章上结<br>思考与练习<br>第6章 抽象工厂模式<br>6.1 抽象工厂模式动机与定义<br>6.2 抽象工厂模式结构与分析<br>6.3 抽象工厂模式实例与解析<br>6.4 抽象工厂模式效果与应用<br>6.5 抽象工厂模式扩展<br>6.6 本章小结<br>思考与练习<br>第7章 建造者模式<br>7.1 建造者模式动机与定义<br>7.2 建造者模式结构与分析<br>7.3 建造者模式实例与解析<br>7.4 建造者模式效果与应用<br>7.5 建造者模式扩展<br>7.6 本章小结<br>思考与练习<br>第8章 原型模式<br>8.1 原型模式动机与定义<br>8.2 原型模式结构与分析<br>8.3 原型模式实例与解析<br>8.4 原型模式效果与应用<br>8.5 原型模式扩展<br>8.6 本章小结<br>思考与练习<br>第9章 单例模式<br>9.1 单例模式动机与定义<br>9.2 单例模式结构与分析<br>9.3 单例模式实例与解析<br>9.4 单例模式效果与应用<br>9.5 单例模式扩展<br>9.6 本章小结<br>思考与练习<br>第10章 适配器模式<br>10.1 结构型模式<br>10.2 适配器模式动机与定义<br>10.3 适配器模式结构与分析<br>10.4 适配器模式实例与解析<br>10.5 适配器模式效果与应用<br>10.6 适配器模式扩展<br>10.7 本章小结<br>思考与练习<br>第11章 桥接模式<br>11.1 桥接模式动机与定义<br>11.2 桥接模式结构与分析<br>11.3 桥接模式实例与解析<br>11.4 桥接模式效果与应用<br>11.5 桥接模式扩展<br>11.6 本章小结<br>思考与练习<br>第12章 组合模式<br>12.1 组合模式动机与定义<br>12.2 组合模式结构与分析<br>12.3 组合模式实例与解析<br>12.4 组合模式效果与应用<br>12.5 组合模式扩展<br>12.6 本章小结<br>思考与练习<br>第13章 装饰模式<br>13.1 装饰模式动机与定义<br>13.2 装饰模式结构与分析<br>13.3 装饰模式实例与解析<br>13.4 装饰模式效果与应用<br>13.5 装饰模式扩展<br>13.6 本章小结<br>思考与练习<br>第14章 外观模式<br>14.1 外观模式动机与定义<br>14.2 外观模式结构与分析<br>14.3 外观模式实例与解析<br>14.4 外观模式效果与应用<br>14.5 外观模式扩展<br>14.6 本章小结<br>思考与练习<br>第15章 享元模式<br>15.1 享元模式动机与定义<br>15.2 享元模式结构与分析<br>15.3 享元模式实例与解析<br>15.4 享元模式效果与应用<br>15.5 享元模式扩展<br>15.6 本章小结<br>思考与练习<br>第16章 代理模式<br>16.1 代理模式动机与定义<br>16.2 代理模式结构与分析<br>16.3 代理模式实例与解析<br>16.4 代理模式效果与应用<br>16.5 代理模式扩展<br>16.6 本章小结<br>思考与练习<br>第17章 职责链模式<br>17.1 行为型模式<br>17.2 职责链模式动机与定义<br>17.3 职责链模式结构与分析<br>17.4 职责链模式实例与解析<br>17.5 职责链模式效果与应用<br>17.6 职责链模式扩展<br>17.7 本章上结<br>思考与练习<br>第18章 命令模式<br>18.1 命令模式动机与定义<br>18.2 命令模式结构与分析<br>18.3 命令模式实例与解析<br>18.4 命令模式效果与应用<br>18.5 命令模式扩展<br>18.6 本章小结<br>思考与练习<br>第19章 解释器模式<br>19.1 解释器模式动机与定义<br>19.2 解释器模式结构与分析<br>19.3 解释器模式实例与解析<br>19.4 解释器模式效果与应用<br>19.5 解释器模式扩展<br>19.6 本章小结<br>思考与练习<br>第20章 迭代器模式<br>20.1 迭代器模式动机与定义<br>20.2 迭代器模式结构与分析<br>20.3 迭代器模式实例与解析<br>20.4 迭代器模式效果与应用<br>20.5 迭代器模式扩展<br>20.6 本章小结<br>思考与练习<br>第21章 中介者模式<br>21.1 中介者模式动机与定义<br>21.2 中介者模式结构与分析<br>21.3 中介者模式实例与解析<br>21.4 中介者模式效果与应用<br>21.5 中介者模式扩展<br>21.6 本章小结<br>思考与练习<br>第22章 备忘录模式<br>22.1 备忘录模式动机与定义<br>22.2 备忘录模式结构与分析<br>22.3 备忘录模式实例与解析<br>22.4 备忘录模式效果与应用<br>22.5 备忘录模式扩展<br>22.6 本章小结<br>思考与练习<br>第23章 观察者模式<br>23.1 观察者模式动机与定义<br>23.2 观察者模式结构与分析<br>23.3 观察者模式实例与解析<br>23.4 观察者模式效果与应用<br>23.5 观察者模式扩展<br>23.6 本章小结<br>思考与练习<br>第24章 状态模式<br>24.1 状态模式动机与定义<br>24.2 状态模式结构与分析<br>24.3 状态模式实例与解析<br>24.4 状态模式效果与应用<br>24.5 状态模式扩展<br>24.6 本章小结<br>思考与练习<br>第25章 策略模式<br>25.1 策略模式动机与定义<br>25.2 策略模式结构与分析<br>25.3 策略模式实例与解析<br>25.4 策略模式效果与应用<br>25.5 策略模式扩展<br>25.6 本章小结<br>思考与练习<br>第26章 模板方法模式<br>26.1 模板方法模式动机与定义<br>26.2 模板方法模式结构与分析<br>26.3 模板方法模式实例与解析<br>26.4 模板方法模式效果与应用<br>26.5 模板方法模式扩展<br>26.6 本章小结<br>思考与练习<br>第27章 访问者模式<br>27.1 访问者模式动机与定义<br>27.2 访问者模式结构与分析<br>27.3 访问者模式实例与解析<br>27.4 访问者模式效果与应用<br>27.5 访问者模式扩展<br>27.6 本章小结<br>思考与练习</p>
<hr>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="简介-16"><a href="#简介-16" class="headerlink" title="简介"></a>简介</h3><p>本书讲述的是计算机工作原理。作者用丰富的想象和清晰的笔墨将看似繁杂的理论阐述得通俗易懂，你丝毫不会感到枯燥和生硬。更重要的是，你会因此而获得对计算机工作原理较深刻的理解。这种理解不是抽象层面上的，而是具有一定深度的。</p>
<h3 id="评价-16"><a href="#评价-16" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/4822685/" target="_blank" rel="noopener">https://book.douban.com/subject/4822685/</a></p>
<h3 id="目录-16"><a href="#目录-16" class="headerlink" title="目录"></a>目录</h3><p>第1章 至亲密友<br>第2章 编码与组合<br>第3章 布莱叶盲文与二进制码<br>第4章 手电筒的剖析<br>第5章 绕过拐角的通信<br>第6章 电报机与继电器<br>第7章 我们的十个数字<br>第8章 十的替代品<br>第9章 二进制数<br>第10章 逻辑与开关<br>第11章 门<br>第12章 二进制加法器<br>第13章 如何实现减法<br>第14章 反馈与触发器<br>第15章 字节与十六进制<br>第16章 存储器组织<br>第17章 自动操作<br>第18章 从算盘到芯片<br>第19章 两种典型的微处理器<br>第20章 ASCII码和字符转换<br>第21章 总线<br>第22章 操作系统<br>第23章 定点数和浮点数<br>第24章 高级语言与低级语言<br>第25章 图形化革命</p>
<hr>
<h2 id="redis开发与运维"><a href="#redis开发与运维" class="headerlink" title="redis开发与运维"></a>redis开发与运维</h2><h3 id="简介-17"><a href="#简介-17" class="headerlink" title="简介"></a>简介</h3><p>本书全面讲解Redis基本功能及其应用，并结合线上开发与运维监控中的实际使用案例，深入分析并总结了实际开发运维中遇到的“陷阱”，以及背后的原因， 包含大规模集群开发与管理的场景、应用案例与开发技巧，为高效开发运维提供了大量实际经验和建议。本书不要求读者有任何Redis使用经验,对入门与进阶DevOps的开发者提供有价值的帮助。主要内容包括：Redis的安装配置、API、各种高效功能、客户端、持久化、复制、高可用、内存、哨兵、集群、缓存设计等，Redis高可用集群解决方案，Redis设计和使用中的问题，最后提供了一个开源工具：Redis监控运维云平台CacheCloud。</p>
<h3 id="评价-17"><a href="#评价-17" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/26971561/" target="_blank" rel="noopener">https://book.douban.com/subject/26971561/</a></p>
<h3 id="目录-17"><a href="#目录-17" class="headerlink" title="目录"></a>目录</h3><p>第1章　初识Redis 1<br>1.1　盛赞Redis 1<br>1.2　Redis特性 2<br>1.3　Redis使用场景 5<br>1.3.1　Redis可以做什么 5<br>1.3.2　Redis不可以做什么 5<br>1.4　用好Redis的建议 6<br>1.5　正确安装并启动Redis 6<br>1.5.1　安装Redis 7<br>1.5.2　配置、启动、操作、关闭Redis 8<br>1.6　Redis重大版本 11<br>1.7　本章重点回顾 14<br>第2章　API的理解和使用 15<br>2.1　预备 15<br>2.1.1　全局命令 15<br>2.1.2　数据结构和内部编码 18<br>2.1.3　单线程架构 19<br>2.2　字符串 21<br>2.2.1　命令 22<br>2.2.2　内部编码 27<br>2.2.3　典型使用场景 28<br>2.3　哈希 31<br>2.3.1　命令 32<br>2.3.2　内部编码 35<br>2.3.3　使用场景 36<br>2.4　列表 38<br>2.4.1　命令 38<br>2.4.2　内部编码 43<br>2.4.3　使用场景 44<br>2.5　集合 46<br>2.5.1　命令 46<br>2.5.2　内部编码 50<br>2.5.3　使用场景 51<br>2.6　有序集合 52<br>2.6.1　命令 53<br>2.6.2　内部编码 59<br>2.6.3　使用场景 59<br>2.7　键管理 60<br>2.7.1　单个键管理 60<br>2.7.2　遍历键 67<br>2.7.3　数据库管理 70<br>2.8　本章重点回顾 73<br>第3章　小功能大用处 74<br>3.1　慢查询分析 74<br>3.1.1　慢查询的两个配置参数 75<br>3.1.2　最佳实践 77<br>3.2　Redis Shell 78<br>3.2.1　redis-cli详解 78<br>3.2.2　redis-server详解 82<br>3.2.3　redis-benchmark详解 83<br>3.3　Pipeline 84<br>3.3.1　Pipeline概念 84<br>3.3.2　性能测试 85<br>3.3.3　原生批量命令与Pipeline对比 86<br>3.3.4　最佳实践 87<br>3.4　事务与Lua 87<br>3.4.1　事务 87<br>3.4.2　Lua用法简述 90<br>3.4.3　Redis与Lua 92<br>3.4.4　案例 94<br>3.4.5　Redis如何管理Lua脚本 96<br>3.5　Bitmaps 98<br>3.5.1　数据结构模型 98<br>3.5.2　命令 98<br>3.5.3　Bitmaps分析 101<br>3.6　HyperLogLog 102<br>3.7　发布订阅 105<br>3.7.1　命令 106<br>3.7.2　使用场景 108<br>3.8　GEO 109<br>3.9　本章重点回顾 112<br>第4章　客户端 113<br>4.1　客户端通信协议 113<br>4.2　Java客户端Jedis 117<br>4.2.1　获取Jedis 117<br>4.2.2　Jedis的基本使用方法 118<br>4.2.3　Jedis连接池的使用方法 122<br>4.2.4　Redis中Pipeline的使用方法 125<br>4.2.5　Jedis的Lua脚本 126<br>4.3　Python客户端redis-py 128<br>4.3.1　获取redis-py 128<br>4.3.2　redis-py的基本使用方法 128<br>4.3.3　redis-py中Pipeline的使用方法 130<br>4.3.4　redis-py中的Lua脚本使用方法 130<br>4.4　客户端管理 131<br>4.4.1　客户端API 132<br>4.4.2　客户端相关配置 145<br>4.4.3　客户端统计片段 145<br>4.5　客户端常见异常 146<br>4.6　客户端案例分析 149<br>4.6.1　Redis内存陡增 149<br>4.6.2　客户端周期性的超时 151<br>4.7　本章重点回顾 153<br>第5章　持久化 154<br>5.1　RDB 154<br>5.1.1　触发机制 154<br>5.1.2　流程说明 155<br>5.1.3　RDB文件的处理 156<br>5.1.4　RDB的优缺点 156<br>5.2　AOF 157<br>5.2.1　使用AOF 157<br>5.2.2　命令写入 157<br>5.2.3　文件同步 158<br>5.2.4　重写机制 159<br>5.2.5　重启加载 161<br>5.2.6　文件校验 162<br>5.3　问题定位与优化 162<br>5.3.1　fork操作 162<br>5.3.2　子进程开销监控和优化 163<br>5.3.3　AOF追加阻塞 165<br>5.4　多实例部署 166<br>5.5　本章重点回顾 167<br>第6章　复制 168<br>6.1　配置 168<br>6.1.1　建立复制 168<br>6.1.2　断开复制 170<br>6.1.3　安全性 170<br>6.1.4　只读 170<br>6.1.5　传输延迟 171<br>6.2　拓扑 171<br>6.3　原理 172<br>6.3.1　复制过程 172<br>6.3.2　数据同步 175<br>6.3.3　全量复制 178<br>6.3.4　部分复制 181<br>6.3.5　心跳 183<br>6.3.6　异步复制 184<br>6.4　开发与运维中的问题 184<br>6.4.1　读写分离 184<br>6.4.2　主从配置不一致 186<br>6.4.3　规避全量复制 186<br>6.4.4　规避复制风暴 187<br>6.5　本章重点回顾 188<br>第7章　Redis的噩梦：阻塞 189<br>7.1　发现阻塞 189<br>7.2　内在原因 191<br>7.2.1　API或数据结构使用不合理 191<br>7.2.2　CPU饱和 193<br>7.2.3　持久化阻塞 194<br>7.3　外在原因 195<br>7.3.1　CPU竞争 195<br>7.3.2　内存交换 195<br>7.3.3　网络问题 196<br>7.4　本章重点回顾 199<br>第8章　理解内存 200<br>8.1　内存消耗 200<br>8.1.1　内存使用统计 200<br>8.1.2　内存消耗划分 201<br>8.1.3　子进程内存消耗 203<br>8.2　内存管理 204<br>8.2.1　设置内存上限 204<br>8.2.2　动态调整内存上限 204<br>8.2.3　内存回收策略 205<br>8.3　内存优化 209<br>8.3.1　redisObject对象 209<br>8.3.2　缩减键值对象 210<br>8.3.3　共享对象池 211<br>8.3.4　字符串优化 213<br>8.3.5　编码优化 216<br>8.3.6　控制键的数量 223<br>8.4　本章重点回顾 225<br>第9章　哨兵 226<br>9.1　基本概念 226<br>9.1.1　主从复制的问题 227<br>9.1.2　高可用 227<br>9.1.3　Redis Sentinel的高可用性 229<br>9.2　安装和部署 232<br>9.2.1　部署拓扑结构 232<br>9.2.2　部署Redis数据节点 233<br>9.2.3　部署Sentinel节点 234<br>9.2.4　配置优化 236<br>9.2.5　部署技巧 243<br>9.3　API 244<br>9.4　客户端连接 249<br>9.4.1　Redis Sentinel的客户端 249<br>9.4.2　Redis Sentinel客户端基本实现原理 249<br>9.4.3　Java操作Redis Sentinel 251<br>9.5　实现原理 254<br>9.5.1　三个定时监控任务 254<br>9.5.2　主观下线和客观下线 256<br>9.5.3　领导者Sentinel节点选举 258<br>9.5.4　故障转移 261<br>9.6　开发与运维中的问题 262<br>9.6.1　故障转移日志分析 262<br>9.6.2　节点运维 268<br>9.6.3　高可用读写分离 271<br>9.7　本章重点回顾 272<br>第10章　集群 274<br>10.1　数据分布 274<br>10.1.1　数据分布理论 274<br>10.1.2　Redis数据分区 277<br>10.1.3　集群功能限制 278<br>10.2　搭建集群 278<br>10.2.1　准备节点 278<br>10.2.2　节点握手 280<br>10.2.3　分配槽 282<br>10.2.4　用redis-trib.rb搭建集群 284<br>10.3　节点通信 287<br>10.3.1　通信流程 287<br>10.3.2　Gossip消息 287<br>10.3.3　节点选择 290<br>10.4　集群伸缩 291<br>10.4.1　伸缩原理 291<br>10.4.2　扩容集群 293<br>10.4.3　收缩集群 301<br>10.5　请求路由 305<br>10.5.1　请求重定向 305<br>10.5.2　Smart客户端 309<br>10.5.3　ASK重定向 318<br>10.6　故障转移 323<br>10.6.1　故障发现 323<br>10.6.2　故障恢复 329<br>10.6.3　故障转移时间 334<br>10.6.4　故障转移演练 334<br>10.7　集群运维 336<br>10.7.1　集群完整性 336<br>10.7.2　带宽消耗 337<br>10.7.3　Pub/Sub广播问题 337<br>10.7.4　集群倾斜 338<br>10.7.5　集群读写分离 339<br>10.7.6　手动故障转移 341<br>10.7.7　数据迁移 344<br>10.8　本章重点回顾 344<br>第11章　缓存设计 346<br>11.1　缓存的收益和成本 346<br>11.2　缓存更新策略 347<br>11.3　缓存粒度控制 349<br>11.4　穿透优化 350<br>11.5　无底洞优化 352<br>11.6　雪崩优化 359<br>11.7　热点key重建优化 360<br>11.8　本章重点回顾 364<br>第12章　开发运维的“陷阱” 365<br>12.1　Linux配置优化 365<br>12.1.1　内存分配控制 365<br>12.1.2　swappiness 367<br>12.1.3　THP 369<br>12.1.4　OOM killer 370<br>12.1.5　使用NTP 371<br>12.1.6　ulimit 371<br>12.1.7　TCP backlog 372<br>12.2　flushall/flushdb误操作 372<br>12.2.1　缓存与存储 373<br>12.2.2　借助AOF机制恢复 373<br>12.2.3　RDB有什么变化 374<br>12.2.4　从节点有什么变化 374<br>12.2.5　快速恢复数据 374<br>12.3　安全的Redis 375<br>12.3.1　Redis密码机制 377<br>12.3.2　伪装危险命令 378<br>12.3.3　防火墙 380<br>12.3.4　bind 380<br>12.3.5　定期备份数据 381<br>12.3.6　不使用默认端口 381<br>12.3.7　使用非root用户启动 381<br>12.4　处理bigkey 382<br>12.4.1　bigkey的危害 382<br>12.4.2　如何发现 382<br>12.4.3　如何删除 383<br>12.4.4　最佳实践思路 386<br>12.5　寻找热点key 386<br>12.6　本章重点回顾 391<br>第13章　Redis监控运维云平台CacheCloud 392<br>13.1　CacheCloud是什么 392<br>13.1.1　现有问题 393<br>13.1.2　CacheCloud基本功能 393<br>13.2　快速部署 395<br>13.2.1　CacheCloud环境需求 395<br>13.2.2　CacheCloud快速开始 395<br>13.3　机器部署 397<br>13.3.1　部署脚本 398<br>13.3.2　添加机器 399<br>13.4　接入应用 400<br>13.4.1　总体流程 401<br>13.4.2　账户申请和审批 401<br>13.4.3　应用申请和审批 402<br>13.4.4　客户端接入 405<br>13.5　用户功能 407<br>13.5.1　应用统计信息 408<br>13.5.2　实例列表 409<br>13.5.3　应用详情 409<br>13.5.4　命令曲线 409<br>13.5.5　CacheCloud Redis Shell控制台 410<br>13.5.6　慢查询 410<br>13.5.7　应用拓扑 411<br>13.6　运维功能 413<br>13.6.1　应用运维 413<br>13.6.2　接入已存在的Redis节点 415<br>13.6.3　Redis配置模板 416<br>13.6.4　迁移工具 417<br>13.6.5　监控报警 420<br>13.6.6　系统配置管理 422<br>13.7　客户端上报 423<br>13.7.1　客户端上报整体设计 424<br>13.7.2　Jedis核心代码修改 424<br>13.7.3　带上报功能的客户端 426<br>13.7.4　CacheCloud客户端统计 427<br>13.8　本章重点回顾 429<br>第14章　Redis配置统计字典 430<br>14.1　info系统状态说明 430<br>14.1.1　命令说明 430<br>14.1.2　详细说明 431<br>14.2　standalone配置说明和分析 436<br>14.2.1　总体配置 436<br>14.2.2　最大内存及策略 437<br>14.2.3　AOF相关配置 437<br>14.2.4　RDB相关配置 438<br>14.2.5　慢查询配置 438<br>14.2.6　数据结构优化配置 439<br>14.2.7　复制相关配置 439<br>14.2.8　客户端相关配置 440<br>14.2.9　安全相关配置 440<br>14.3　Sentinel配置说明和分析 440<br>14.4　Cluster配置说明和分析 441</p>
<hr>
<h2 id="mysql从入门到精通"><a href="#mysql从入门到精通" class="headerlink" title="mysql从入门到精通"></a>mysql从入门到精通</h2><h3 id="简介-18"><a href="#简介-18" class="headerlink" title="简介"></a>简介</h3><p>适合的往往是最实用的，就像我们要讲述的MySQL一样，它的功能不是最全面的，架构也不是最完善的，但是其体积小、速度快、总体拥有和维护成本低，尤其是它具备开放源码的优势，使其迅速成为中小型企业和网站的数据库。<br>本书共分为4个部分（篇）和5个附录。其中第1篇为MySQL数据库基础篇，内容包括数据库所涉及的基本概念、MySQL数据库的安装与配置等。第2篇为MySQL数据库操作和应用篇，内容包括操作数据库对象、操作表对象、操作索引对象、操作视图对象、操作触发器对象和操作数据等。第3篇为MySQL数据库管理篇，内容包括MySQL数据库的用户管理和权限管理、MySQL数据库的日志管理、MySQL数据库的性能优化等。第4篇为MySQL数据库实战案例篇，内容包括Java+MySQL案例——在线书城和PHP+MySQL案例——智能考试系统两个实战案例。附录部分（光盘中）包括了MySQL数据库操作和管理技巧，以提升读者的应用技能；同时还向读者介绍了Power Designer数据库设计软件的内容。<br>秉承注重理论与实际开发相结合的原则，书中的每个技术点都配备了与之相对应的实例，旨在帮助MySQL数据库初学者快速入门，同时也适合MySQL数据库管理员和想全面学习MySQL数据库技术以提升应用水平的人员使用。</p>
<h3 id="评价-18"><a href="#评价-18" class="headerlink" title="评价"></a>评价</h3><p><a href="https://book.douban.com/subject/20260737/" target="_blank" rel="noopener">https://book.douban.com/subject/20260737/</a></p>
<h3 id="目录-18"><a href="#目录-18" class="headerlink" title="目录"></a>目录</h3><p>暂无</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.tzxcode.cn/books/index.html" data-id="ckbm0xkx7009s6ovhc8b0bs1d" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
  <div class="comments" id="comments">
    
     
       
       
            <div id="SOHUCS" ></div> 
<script type="text/javascript"> 
(function(){ 
var appid = 'cyuD50Pqv'; 
var conf = 'prod_4668108628adf4b398aa4219d3653b94'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) {
var head = document.getElementsByTagName('head')[0]||document.head||document.documentElement;
var script = document.createElement('script');
script.type = 'text/javascript';
script.charset = 'utf-8';
script.id = 'changyan_mobile_js';
script.src = 'https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf;
head.appendChild(script);
} else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
      
      
	 
  </div>
 
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =5
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

	
  
</article>

</section>
           
    <aside id="sidebar">
  
    <!--微信公众号二维码-->


  
    

  
    
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#我的书单"><span class="toc-number">1.</span> <span class="toc-text">我的书单</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2017年（已购纸质书籍）"><span class="toc-number">1.1.</span> <span class="toc-text">2017年（已购纸质书籍）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#他人推荐书单"><span class="toc-number">2.</span> <span class="toc-text">他人推荐书单</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#已购书籍简介和目录"><span class="toc-number">3.</span> <span class="toc-text">已购书籍简介和目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java核心技术"><span class="toc-number">3.1.</span> <span class="toc-text">java核心技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">3.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价"><span class="toc-number">3.1.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录"><span class="toc-number">3.1.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#effectivejava中文版"><span class="toc-number">3.2.</span> <span class="toc-text">effectivejava中文版</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java编程思想"><span class="toc-number">3.3.</span> <span class="toc-text">java编程思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-2"><span class="toc-number">3.3.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java并发编程核心方法与框架"><span class="toc-number">3.4.</span> <span class="toc-text">java并发编程核心方法与框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-3"><span class="toc-number">3.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-3"><span class="toc-number">3.4.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-3"><span class="toc-number">3.4.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java并发编程实战"><span class="toc-number">3.5.</span> <span class="toc-text">java并发编程实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-4"><span class="toc-number">3.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-4"><span class="toc-number">3.5.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-4"><span class="toc-number">3.5.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java面试宝典"><span class="toc-number">3.6.</span> <span class="toc-text">java面试宝典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-5"><span class="toc-number">3.6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-5"><span class="toc-number">3.6.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-5"><span class="toc-number">3.6.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深入分析javaweb技术内幕"><span class="toc-number">3.7.</span> <span class="toc-text">深入分析javaweb技术内幕</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-6"><span class="toc-number">3.7.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-6"><span class="toc-number">3.7.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-6"><span class="toc-number">3.7.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java性能优化权威指南"><span class="toc-number">3.8.</span> <span class="toc-text">java性能优化权威指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-7"><span class="toc-number">3.8.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-7"><span class="toc-number">3.8.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-7"><span class="toc-number">3.8.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring入门经典"><span class="toc-number">3.9.</span> <span class="toc-text">spring入门经典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-8"><span class="toc-number">3.9.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-8"><span class="toc-number">3.9.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-8"><span class="toc-number">3.9.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#springboot实战"><span class="toc-number">3.10.</span> <span class="toc-text">springboot实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-9"><span class="toc-number">3.10.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-9"><span class="toc-number">3.10.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-9"><span class="toc-number">3.10.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#springmvc学习指南"><span class="toc-number">3.11.</span> <span class="toc-text">springmvc学习指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-10"><span class="toc-number">3.11.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-10"><span class="toc-number">3.11.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-10"><span class="toc-number">3.11.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#maven实战"><span class="toc-number">3.12.</span> <span class="toc-text">maven实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-11"><span class="toc-number">3.12.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-11"><span class="toc-number">3.12.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-11"><span class="toc-number">3.12.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eclipse精粹"><span class="toc-number">3.13.</span> <span class="toc-text">eclipse精粹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-12"><span class="toc-number">3.13.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-12"><span class="toc-number">3.13.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-12"><span class="toc-number">3.13.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tomcat权威指南"><span class="toc-number">3.14.</span> <span class="toc-text">tomcat权威指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-13"><span class="toc-number">3.14.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-13"><span class="toc-number">3.14.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-13"><span class="toc-number">3.14.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#headFirst设计模式"><span class="toc-number">3.15.</span> <span class="toc-text">headFirst设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-14"><span class="toc-number">3.15.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-14"><span class="toc-number">3.15.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-14"><span class="toc-number">3.15.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式"><span class="toc-number">3.16.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-15"><span class="toc-number">3.16.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-15"><span class="toc-number">3.16.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-15"><span class="toc-number">3.16.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编码"><span class="toc-number">3.17.</span> <span class="toc-text">编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-16"><span class="toc-number">3.17.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-16"><span class="toc-number">3.17.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-16"><span class="toc-number">3.17.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis开发与运维"><span class="toc-number">3.18.</span> <span class="toc-text">redis开发与运维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-17"><span class="toc-number">3.18.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-17"><span class="toc-number">3.18.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-17"><span class="toc-number">3.18.3.</span> <span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql从入门到精通"><span class="toc-number">3.19.</span> <span class="toc-text">mysql从入门到精通</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-18"><span class="toc-number">3.19.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评价-18"><span class="toc-number">3.19.2.</span> <span class="toc-text">评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录-18"><span class="toc-number">3.19.3.</span> <span class="toc-text">目录</span></a></li></ol></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2016 - 2020 涂宗勋&nbsp; <a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">鄂ICP备20000142号</a> |&nbsp;&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>&nbsp;|&nbsp;&nbsp;
	  <span id="busuanzi_container_site_uv">本站有效访客数<span id="busuanzi_value_site_uv"></span>人</span>
	  <div style="width:300px;margin:0 auto; padding:20px 0;"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42010302002171"style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="http://www.tzxcode.cn/wp-content/uploads/2020/01/备案图标.png" style="float:left;"/><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">鄂公网安备 42010302002171号</p></a>
		 	</div>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;1160569243@qq.com
    </div>
	
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

 
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/shuoshuo/" class="mobile-nav-link">说说</a>
  
    <a href="/archives/" class="mobile-nav-link">归档</a>
  
    <a href="/collections/" class="mobile-nav-link">收藏</a>
  
    <a href="/download/" class="mobile-nav-link">资源</a>
  
    <a href="/about/" class="mobile-nav-link">简历</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      



<script type="text/javascript ">
    (function () {
        var appid = 'cytYCbn4s';
        var conf = 'e18ab73896248d40bda4389d7380020f';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
        } else {
            var loadJs = function (d, a) {
                var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
                var b = document.createElement("script");
                b.setAttribute("type", "text/javascript");
                b.setAttribute("charset", "UTF-8");
                b.setAttribute("src", d);
                if (typeof a === "function") {
                    if (window.attachEvent) {
                        b.onreadystatechange = function () {
                            var e = b.readyState;
                            if (e === "loaded" || e === "complete") {
                                b.onreadystatechange = null;
                                a()
                            }
                        }
                    } else {
                        b.onload = a
                    }
                }
                c.appendChild(b)
            };
            loadJs("http://changyan.sohu.com/upload/changyan.js", function () {
                window.changyan.api.config({
                    appid: appid,
                    conf: conf
                })
            });
        }
    })();
</script>








<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->



 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>