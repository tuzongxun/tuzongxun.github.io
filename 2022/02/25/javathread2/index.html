<!DOCTYPE html>
<html xmlns:wb="http://open.weibo.com/wb">
<head>
  <meta charset="utf-8">
  <script src="https://cdn.jsdelivr.net/gh/Sanarous/files@1.13/js/linkcard.js"></script>
  <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fc9a8559a133f4d8ce784d69d6337bb0";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  
  <title>java基础之多线程总结二（CAS和各种常用锁） | 涂宗勋的博客</title>
  <meta name="baidu-site-verification" content="o8pWlgAEZ7" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="CAS在java中，对很多常见的需要加锁的操作进行了封装，例如Atomic开头的一些类，这些类是线程安全的，但是内部却不是用synchronized加锁实现，而是CAS。例如AtomicInteger的’incrementAndGet()’方法最终调用的实际是下边这个方法 1234@HotSpotIntrinsicCandidate    public final native boolean c">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础之多线程总结二（CAS和各种常用锁）">
<meta property="og:url" content="http://blog.tzxcode.cn/2022/02/25/javathread2/index.html">
<meta property="og:site_name" content="涂宗勋的博客">
<meta property="og:description" content="CAS在java中，对很多常见的需要加锁的操作进行了封装，例如Atomic开头的一些类，这些类是线程安全的，但是内部却不是用synchronized加锁实现，而是CAS。例如AtomicInteger的’incrementAndGet()’方法最终调用的实际是下边这个方法 1234@HotSpotIntrinsicCandidate    public final native boolean c">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-25T10:43:58.000Z">
<meta property="article:modified_time" content="2022-03-28T02:39:52.842Z">
<meta property="article:author" content="涂宗勋">
<meta property="article:tag" content="java">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/images/touxiang.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <script src="https://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
  <script src="https://cdn.jsdelivr.net/gh/Sanarous/files@1.13/js/linkcard.js"></script>
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.tzxcode.cn"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/shuoshuo/">说说</a>
        
          <a class="main-nav-link" href="/archives/">归档</a>
        
          <a class="main-nav-link" href="/collections/">导航</a>
        
          <a class="main-nav-link" href="/download/">资源</a>
        
          <a class="main-nav-link" href="/about/">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">涂宗勋的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">java全栈程序员，CSDN博客https://blog.csdn.net/tuzongxun</a>&nbsp;&nbsp;&nbsp;&nbsp;
		  <!--<span id="busuanzi_container_site_pv">【本站累计访问量:<span id="busuanzi_value_site_pv"></span>】</span>-->
        </h2>
		
      
    </div>
  </div>
</header>
	  
      <div class="outer">
		<a href="https://tuzongxun.blog.csdn.net/" target="_blank" rel="noopener">
			<img style="width:98%;height:100px;margin-top:30px;margin-left:2%" src="/images/mycsdn.jpg">
		</a>
        <section id="main">
			
			<article id="post-javathread2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/25/javathread2/" class="article-date">
  <time datetime="2022-02-25T10:43:58.000Z" itemprop="datePublished">2022-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

</span>
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java基础之多线程总结二（CAS和各种常用锁）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>在java中，对很多常见的需要加锁的操作进行了封装，例如Atomic开头的一些类，这些类是线程安全的，但是内部却不是用synchronized加锁实现，而是CAS。<br>例如AtomicInteger的’incrementAndGet()’方法最终调用的实际是下边这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">    public final native boolean compareAndSetInt(Object o, long offset,</span><br><span class="line">                                                 int expected,</span><br><span class="line">                                                 int x);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这个本地方法在一个比较特殊的类中，即Unsafe，这个类可以直接进行内存管理等操作，且源码可以看出来这是一个典型的单例模式。<br>CAS是compare and set的缩写，即比较并设值的意思，CAS之所以能保证线程安全，是因为这类操作是cpu原语支持的，执行过程中不能被打断。<br>CAS操作会有ABA问题，意思就是一个线程在操作的时候，另一个线程把数据修改了，然后又改了回去，单纯比较值似乎没有变化。<br>ABA问题对于基础数据类型的数据其实没有太大影响，如果不是基础类型，并且必须处理ABA问题，可以考虑增加版本号管理，在compare的时候连版本号一起比较。<br>就像AtomicInteger类，如果要处理ABA问题可以考虑使用AtomicStampedReference类。</p>
<p>Atomic这一类操作的CAS是无锁的，所以有的时候比synchronized的效率要高，而针对数据自增这种操作，jdk还自带了一些其他的类，例如LongAdder，LongAdder采用的也是CAS，但是是分段的，所以一些应用场景下可能性能更好，例如有这样一段测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Author tuzongxun</span><br><span class="line"> * @Date 2022&#x2F;2&#x2F;23</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class LongAddrDemo &#123;</span><br><span class="line">	private static Long count1 &#x3D; 0L;</span><br><span class="line"></span><br><span class="line">	private static AtomicLong count2 &#x3D; new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">	private static LongAdder count3 &#x3D; new LongAdder();</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread[] threads &#x3D; new Thread[1000];</span><br><span class="line"></span><br><span class="line">		Object o &#x3D; new Object();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">			threads[i] &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">				for (int j &#x3D; 0; j &lt; 100000; j++) &#123;</span><br><span class="line">					synchronized (o) &#123;</span><br><span class="line">						count1++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Long t1 &#x3D; System.currentTimeMillis();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">			threads[i].start();</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				threads[i].join();</span><br><span class="line">			&#125;</span><br><span class="line">			catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Long t2 &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;count1-synchronized:&quot; + count1 + &quot;:&quot; + (t2 - t1));</span><br><span class="line">		&#x2F;&#x2F;############################################</span><br><span class="line">		for (int i &#x3D; 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">			threads[i] &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">				for (int j &#x3D; 0; j &lt; 100000; j++) &#123;</span><br><span class="line">					count2.incrementAndGet();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Long t11 &#x3D; System.currentTimeMillis();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">			threads[i].start();</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				threads[i].join();</span><br><span class="line">			&#125;</span><br><span class="line">			catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Long t12 &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;count2-Atomic:&quot;+count2 + &quot;:&quot; + (t12 - t11));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;############################################</span><br><span class="line">		for (int i &#x3D; 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">			threads[i] &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">				for (int j &#x3D; 0; j &lt; 100000; j++) &#123;</span><br><span class="line">					count3.increment();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Long t21 &#x3D; System.currentTimeMillis();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">			threads[i].start();</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				threads[i].join();</span><br><span class="line">			&#125;</span><br><span class="line">			catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Long t22 &#x3D; System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;count3-LongAdder:&quot;+count3 + &quot;:&quot; + (t22 - t21));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行后结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count1-synchronized:100000000:6060</span><br><span class="line">count2-Atomic:100000000:2149</span><br><span class="line">count3-LongAdder:100000000:499</span><br></pre></td></tr></table></figure>

<p>很明显，针对当前的测试，LongAdder的性能高于AtomicLong，AtomicLong的性能要高于synchronized。<br>但是需要注意的是，上边的结论只是针对于当前场景，并不是说什么时候都是这样，具体应用的时候还需要进行实际分析和测试确定。</p>
<h2 id="各种锁"><a href="#各种锁" class="headerlink" title="各种锁"></a>各种锁</h2><p>jdk中有很多使用CAS实现的锁，例如ReentrantLock，ReenTrantLock相比synchronized更加灵活，不过从实现上来说可能稍微麻烦些，其中有一点就是需要手动解锁，例如如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Author tuzongxun</span><br><span class="line"> * @Date 2022&#x2F;2&#x2F;23</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class LockDemo &#123;</span><br><span class="line">	private static int count&#x3D;0;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ReentrantLock lock&#x3D;new ReentrantLock();</span><br><span class="line">		Thread t1&#x3D;new Thread(()-&gt;&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			for (int i &#x3D; 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread t2&#x3D;new Thread(()-&gt;&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			for (int i &#x3D; 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;);</span><br><span class="line">		try &#123;</span><br><span class="line">			t1.start();</span><br><span class="line">			t2.start();</span><br><span class="line">			t1.join();</span><br><span class="line">			t2.join();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边的代码总能输出2000000，是线程安全的。需要注意的是，这里的unlock最后必须手动调用，上边的代码比较简单，所以没有过多处理，正常来说应该加入到finally代码块中以保证一定被调用。<br>之所以说ReentrantLock灵活，是因为它可以被打断，使用lockInterruptibly()，在创建lock对象的时候，还可以选择使用公平锁还是非公平锁，默认是非公平的，如果要公平，则可以在后边参数中传true，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock&#x3D;new ReentrantLock(true);</span><br></pre></td></tr></table></figure>

<p>所谓的公平锁可以简单地理解为先来后到，而不是来了就直接·抢。</p>
<p>上边的代码，在main线程中使用了join方法等待两个线程结束，然后输出最终结果，实际上还可以用CountDownLatch替换这种写法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Author tuzongxun</span><br><span class="line"> * @Date 2022&#x2F;2&#x2F;24</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line">	private static int count&#x3D;0;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ReentrantLock lock&#x3D;new ReentrantLock(true);</span><br><span class="line">		CountDownLatch cd&#x3D;new CountDownLatch(2);</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			for (int i &#x3D; 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			lock.unlock();</span><br><span class="line">			cd.countDown();</span><br><span class="line">		&#125;).start();</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			for (int i &#x3D; 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			lock.unlock();</span><br><span class="line">			cd.countDown();</span><br><span class="line">		&#125;).start();</span><br><span class="line">		try &#123;</span><br><span class="line">			cd.await();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，CountDownLatch关键在于创建对象的时候定义的数量以及调用countDown方法，所以实际上可以在一个线程里多次调用countDown把数量减到零，这是需要写程序的时候自己控制的。</p>
<p>上边用到的ReentrantLock和synchronized比较类似，都是排他锁，这种锁在读多写少需要读写分离的场景中就有些不够用，相对来说效率也不够高，例如如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Author tuzongxun</span><br><span class="line"> * @Date 2022&#x2F;2&#x2F;24</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ReentrantLockDemo2 &#123;</span><br><span class="line">	private static int count&#x3D;0;</span><br><span class="line">	private static ReentrantLock reentrantLock&#x3D;new ReentrantLock();</span><br><span class="line">	public static void readCount(Lock lock)&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			Thread.sleep(1000);</span><br><span class="line">			System.out.println(new Date() +&quot;----&quot;+count);</span><br><span class="line">		&#125;catch (Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void writeCount(Lock lock)&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			Thread.sleep(1000);</span><br><span class="line">			count++;</span><br><span class="line">			System.out.println(new Date() +&quot;----&quot;+count);</span><br><span class="line">		&#125;catch (Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">			new Thread(()-&gt;&#123;</span><br><span class="line">				readCount(reentrantLock);</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">			new Thread(()-&gt;&#123;</span><br><span class="line">				writeCount(reentrantLock);</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thu Feb 24 20:32:38 CST 2022----0</span><br><span class="line">Thu Feb 24 20:32:39 CST 2022----0</span><br><span class="line">Thu Feb 24 20:32:40 CST 2022----0</span><br><span class="line">Thu Feb 24 20:32:41 CST 2022----0</span><br><span class="line">Thu Feb 24 20:32:42 CST 2022----0</span><br><span class="line">Thu Feb 24 20:32:43 CST 2022----1</span><br><span class="line">Thu Feb 24 20:32:44 CST 2022----2</span><br><span class="line">Thu Feb 24 20:32:45 CST 2022----3</span><br><span class="line">Thu Feb 24 20:32:46 CST 2022----4</span><br><span class="line">Thu Feb 24 20:32:47 CST 2022----5</span><br></pre></td></tr></table></figure>

<p>可以看到这里不论是读还是写，都会独自占用一秒时间，总共花费10秒。<br>实际上，有一种读写分离的锁可以使的读锁共享，写锁排他，从而在适当的应用场景下提升效率，例如上边代码可以改成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Author tuzongxun</span><br><span class="line"> * @Date 2022&#x2F;2&#x2F;24</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ReentrantLockDemo2 &#123;</span><br><span class="line">	private static int count&#x3D;0;</span><br><span class="line">	private static ReentrantReadWriteLock reentrantReadWriteLock&#x3D;new ReentrantReadWriteLock();</span><br><span class="line">	private static Lock readLock&#x3D;reentrantReadWriteLock.readLock();</span><br><span class="line">	private static Lock writeLock&#x3D;reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">	public static void readCount(Lock lock)&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			Thread.sleep(1000);</span><br><span class="line">			System.out.println(new Date() +&quot;----&quot;+count);</span><br><span class="line">		&#125;catch (Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void writeCount(Lock lock)&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			Thread.sleep(1000);</span><br><span class="line">			count++;</span><br><span class="line">			System.out.println(new Date() +&quot;----&quot;+count);</span><br><span class="line">		&#125;catch (Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">			new Thread(()-&gt;&#123;</span><br><span class="line">				readCount(readLock);</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">			new Thread(()-&gt;&#123;</span><br><span class="line">				writeCount(writeLock);</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thu Feb 24 20:36:18 CST 2022----0</span><br><span class="line">Thu Feb 24 20:36:18 CST 2022----0</span><br><span class="line">Thu Feb 24 20:36:18 CST 2022----0</span><br><span class="line">Thu Feb 24 20:36:18 CST 2022----0</span><br><span class="line">Thu Feb 24 20:36:18 CST 2022----0</span><br><span class="line">Thu Feb 24 20:36:19 CST 2022----1</span><br><span class="line">Thu Feb 24 20:36:20 CST 2022----2</span><br><span class="line">Thu Feb 24 20:36:21 CST 2022----3</span><br><span class="line">Thu Feb 24 20:36:22 CST 2022----4</span><br><span class="line">Thu Feb 24 20:36:23 CST 2022----5</span><br></pre></td></tr></table></figure>

<p>可以看到这里实际上只花费了5秒，写的操作每个占用了1秒，所有读的操作都在同一秒内完成了。这里的代码和上边的相比，只是用了不同的锁。</p>
<p>jdk中还有一个类，可以实现指定数量的线程都到齐之后再开始运行，这个类就是CyclicBarrier，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Author tuzongxun</span><br><span class="line"> * @Date 2022&#x2F;2&#x2F;24</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		CyclicBarrier cb&#x3D;new CyclicBarrier(20,()-&gt;&#123;</span><br><span class="line">			System.out.println(&quot;数量凑齐，开始运行-------------------:&quot;+new Date());</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt;41 ; i++) &#123;</span><br><span class="line">			System.out.println(&quot;创建线程：&quot;+(i+1)+new Date());</span><br><span class="line">			new Thread(()-&gt;&#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					cb.await();</span><br><span class="line">					System.out.println(&quot;开始运行：&quot;+new Date());</span><br><span class="line">				&#125;</span><br><span class="line">				catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				catch (BrokenBarrierException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">创建线程：1Thu Feb 24 19:52:27 CST 2022</span><br><span class="line">创建线程：2Thu Feb 24 19:52:28 CST 2022</span><br><span class="line">创建线程：3Thu Feb 24 19:52:29 CST 2022</span><br><span class="line">创建线程：4Thu Feb 24 19:52:30 CST 2022</span><br><span class="line">创建线程：5Thu Feb 24 19:52:31 CST 2022</span><br><span class="line">创建线程：6Thu Feb 24 19:52:32 CST 2022</span><br><span class="line">创建线程：7Thu Feb 24 19:52:33 CST 2022</span><br><span class="line">创建线程：8Thu Feb 24 19:52:34 CST 2022</span><br><span class="line">创建线程：9Thu Feb 24 19:52:35 CST 2022</span><br><span class="line">创建线程：10Thu Feb 24 19:52:36 CST 2022</span><br><span class="line">创建线程：11Thu Feb 24 19:52:37 CST 2022</span><br><span class="line">创建线程：12Thu Feb 24 19:52:38 CST 2022</span><br><span class="line">创建线程：13Thu Feb 24 19:52:39 CST 2022</span><br><span class="line">创建线程：14Thu Feb 24 19:52:40 CST 2022</span><br><span class="line">创建线程：15Thu Feb 24 19:52:41 CST 2022</span><br><span class="line">创建线程：16Thu Feb 24 19:52:42 CST 2022</span><br><span class="line">创建线程：17Thu Feb 24 19:52:43 CST 2022</span><br><span class="line">创建线程：18Thu Feb 24 19:52:44 CST 2022</span><br><span class="line">创建线程：19Thu Feb 24 19:52:45 CST 2022</span><br><span class="line">创建线程：20Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">数量凑齐，开始运行-------------------:Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:52:46 CST 2022</span><br><span class="line">创建线程：21Thu Feb 24 19:52:47 CST 2022</span><br><span class="line">创建线程：22Thu Feb 24 19:52:48 CST 2022</span><br><span class="line">创建线程：23Thu Feb 24 19:52:49 CST 2022</span><br><span class="line">创建线程：24Thu Feb 24 19:52:50 CST 2022</span><br><span class="line">创建线程：25Thu Feb 24 19:52:51 CST 2022</span><br><span class="line">创建线程：26Thu Feb 24 19:52:52 CST 2022</span><br><span class="line">创建线程：27Thu Feb 24 19:52:53 CST 2022</span><br><span class="line">创建线程：28Thu Feb 24 19:52:54 CST 2022</span><br><span class="line">创建线程：29Thu Feb 24 19:52:55 CST 2022</span><br><span class="line">创建线程：30Thu Feb 24 19:52:56 CST 2022</span><br><span class="line">创建线程：31Thu Feb 24 19:52:57 CST 2022</span><br><span class="line">创建线程：32Thu Feb 24 19:52:58 CST 2022</span><br><span class="line">创建线程：33Thu Feb 24 19:52:59 CST 2022</span><br><span class="line">创建线程：34Thu Feb 24 19:53:00 CST 2022</span><br><span class="line">创建线程：35Thu Feb 24 19:53:01 CST 2022</span><br><span class="line">创建线程：36Thu Feb 24 19:53:02 CST 2022</span><br><span class="line">创建线程：37Thu Feb 24 19:53:03 CST 2022</span><br><span class="line">创建线程：38Thu Feb 24 19:53:04 CST 2022</span><br><span class="line">创建线程：39Thu Feb 24 19:53:05 CST 2022</span><br><span class="line">创建线程：40Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">数量凑齐，开始运行-------------------:Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">开始运行：Thu Feb 24 19:53:06 CST 2022</span><br><span class="line">创建线程：41Thu Feb 24 19:53:07 CST 2022</span><br></pre></td></tr></table></figure>

<p>从上述结果可以看出，只有20个线程都准备好了之后才会开始运行，并且这个程序如果不手动关闭，则会一直处理运行等待状态。</p>
<p>jdk中还有一个线程相关的类，可以实现类似限流的操作，可以设定允许同时运行的线程数量，这个类就是Semaphore，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Author tuzongxun</span><br><span class="line"> * @Date 2022&#x2F;2&#x2F;24</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Semaphore sd&#x3D;new Semaphore(2);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">			new Thread(()-&gt;&#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					sd.acquire();</span><br><span class="line">					System.out.println(new Date());</span><br><span class="line">					Thread.sleep(1000);</span><br><span class="line">				&#125;</span><br><span class="line">				catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;finally &#123;</span><br><span class="line">					sd.release();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建Semaphore对象时传入了参数2，意思就是同时运行有2个线程运行，上述代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thu Feb 24 20:48:57 CST 2022</span><br><span class="line">Thu Feb 24 20:48:57 CST 2022</span><br><span class="line">Thu Feb 24 20:48:58 CST 2022</span><br><span class="line">Thu Feb 24 20:48:58 CST 2022</span><br><span class="line">Thu Feb 24 20:48:59 CST 2022</span><br><span class="line">Thu Feb 24 20:48:59 CST 2022</span><br><span class="line">Thu Feb 24 20:49:00 CST 2022</span><br><span class="line">Thu Feb 24 20:49:00 CST 2022</span><br><span class="line">Thu Feb 24 20:49:01 CST 2022</span><br><span class="line">Thu Feb 24 20:49:01 CST 2022</span><br></pre></td></tr></table></figure>

<p>可以看到，每秒只有两个结果是一样的。如果把上边对象的2改成5，则运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thu Feb 24 20:53:21 CST 2022</span><br><span class="line">Thu Feb 24 20:53:21 CST 2022</span><br><span class="line">Thu Feb 24 20:53:21 CST 2022</span><br><span class="line">Thu Feb 24 20:53:21 CST 2022</span><br><span class="line">Thu Feb 24 20:53:21 CST 2022</span><br><span class="line">Thu Feb 24 20:53:22 CST 2022</span><br><span class="line">Thu Feb 24 20:53:22 CST 2022</span><br><span class="line">Thu Feb 24 20:53:22 CST 2022</span><br><span class="line">Thu Feb 24 20:53:22 CST 2022</span><br><span class="line">Thu Feb 24 20:53:22 CST 2022</span><br></pre></td></tr></table></figure>

<p>即同一秒有5个线程在运行。<br>需要注意的是，这个类也是支持公平锁和非公平锁的，默认是非公平，如果要使用公平锁，则可以这样增加第二个参数，设置为true，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore sd&#x3D;new Semaphore(5,true);</span><br></pre></td></tr></table></figure>

<p>除了上述加锁用法，还有一个也比较常用的锁相关的类LockSupport，用法示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Author tuzongxun</span><br><span class="line"> * @Date 2022&#x2F;2&#x2F;24</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class LockSupportDemo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread t &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">				if (i &#x3D;&#x3D; 3) &#123;</span><br><span class="line">					LockSupport.park();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(i + &quot;:&quot; + new Date());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t.start();</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(3000);</span><br><span class="line">			LockSupport.unpark(t);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:Thu Feb 24 23:58:50 CST 2022</span><br><span class="line">1:Thu Feb 24 23:58:50 CST 2022</span><br><span class="line">2:Thu Feb 24 23:58:50 CST 2022</span><br><span class="line">3:Thu Feb 24 23:58:53 CST 2022</span><br><span class="line">4:Thu Feb 24 23:58:53 CST 2022</span><br><span class="line">5:Thu Feb 24 23:58:53 CST 2022</span><br><span class="line">6:Thu Feb 24 23:58:53 CST 2022</span><br><span class="line">7:Thu Feb 24 23:58:53 CST 2022</span><br><span class="line">8:Thu Feb 24 23:58:53 CST 2022</span><br><span class="line">9:Thu Feb 24 23:58:53 CST 2022</span><br></pre></td></tr></table></figure>

<p>可以很明显的看到线程在park加锁后就进入了阻塞状态，在调用了unpark之后才开始继续运行。<br>线程锁相关的用法很多，各种锁都有自己的适用场景，没有绝对的哪个更好，甚至有的时候可能用哪个都差不多，这些都需要具体需要的时候分析以及测试。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.tzxcode.cn/2022/02/25/javathread2/" data-id="cl22qaxho004t18vh7xzy9asz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
    
  <div class="comments" id="comments">
    
     
       
       
      
      
	 
  </div>
 
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =5
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

	
<nav id="article-nav">
  
    <a href="/2022/02/27/javathread3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          java基础之多线程总结三（AQS、ThreadLocal和线程池）
        
      </div>
    </a>
  
  
    <a href="/2022/02/25/zuullimit/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">使用spring-cloud-zuul-rate-limit在zuul中为服务限流</div>
    </a>
  
</nav>

  
</article>


		</section>
           
    <aside id="sidebar">
  
    <!--微信公众号二维码-->


  
    

  
    
  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed" style="max-height: 300px;">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">1.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各种锁"><span class="toc-number">2.</span> <span class="toc-text">各种锁</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2016 - 2022 涂宗勋&nbsp; <a href="https://beian.miit.gov.cn/#/Integrated/recordQuery" target="_blank" rel="noopener">鄂ICP备20000142号</a> |&nbsp;&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>&nbsp;|&nbsp;&nbsp;
	  <span id="busuanzi_container_site_pv">历史访问<span style="color:#2D7023" id="busuanzi_value_site_pv"></span>次</span>
	  <div style="width:300px;margin:0 auto; padding:20px 0;"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42010302002171"style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="https://blog.tzxcode.cn/beian.png" style="float:left;"/><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">鄂公网安备 42010302002171号</p></a>
		 	</div>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;1160569243@qq.com
    </div>
	
  </div>
</footer>

<script src="/jquery/jquery.min.js"></script>

<script>
$(document).ready(function() {
	var int = setInterval(fixCount, 50);  // 50ms周期检测函数
	var countOffset = 50000;  // 初始化首次数据
	function fixCount() {            
		if (document.getElementById("busuanzi_container_site_pv").style.display != "none"){
			$("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
			clearInterval(int);
		}                  
		if ($("#busuanzi_container_site_pv").css("display") != "none"){
			$("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
			clearInterval(int); // 停止检测
		}  
	}      	
});
</script> 
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/shuoshuo/" class="mobile-nav-link">说说</a>
  
    <a href="/archives/" class="mobile-nav-link">归档</a>
  
    <a href="/collections/" class="mobile-nav-link">导航</a>
  
    <a href="/download/" class="mobile-nav-link">资源</a>
  
    <a href="/about/" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>