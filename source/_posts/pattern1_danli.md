---
title: 【java设计模式初探0】_单例模式
date: 2017-09-24 18:43:58
categories: 设计模式 #分类
toc: true  #在此处设定是否开启目录，需要主题支持。
tags: 设计模式
---
在java的几十种设计模式中，可能单例模式算是最容易理解的吧！因为不论是目前的我自己，还是偶尔面试的别人，能稍微讲清楚的，基本就是单例模式。 
什么叫单例模式？顾名思义，就是单一的实例，唯一的实 例。也就是说对于某个java类来说，他的实例对象最多只能创建一个。
<!--more-->
那么，稍微有点java基础的同学都知道，我们自己创建对象最基本的方式就是使用new关键字，通过类定义的构造器来创建。就比如有这样一个类：
<pre> 
	public class Earth{
     public Earth(){
     }
    }
</pre>
我们自己创建该类的对象，一般就是new Earth()，那么很显然的，这种情况下我们每new一次，这个类就会有一个新的对象实例。 
如此一来，也就是说只要这个类有了可以供外部调用的构造器，那么就必然无法控制这个类的实例个数。 
也就是说，如果我们希望这个类的实例只有一个，就必须把类的构造器访问权限设置成private，使得外部无法调用。就如下边这样：
<pre>   
	public class Earth{
     private Earth(){
     }
    }
</pre>
那么问题又来了，既然类的构造器都是private，那么我们又该如何创建这个类的实例对象呢？ 
这时候就需要知道一个基础的知识点：实际上在java中创建对象，归根结底都只能使用构造器创建，不论是使用框架（框架内部）还是直接使用普通代码！ 
也就是说，即使这个类的构造器是private的，我们也还是只能使用类构造器来创建这个类的实例对象。 
如此一来，便又涉及到一个java很基础的知识点，我们知道private修饰的方法只有当前类才能使用，那么很显然的，对于构造器是private的类，我们也就只能在这个类的内部创建类的实例对象了。
<pre>
    public class Earth{
     private Earth(){
     }
     Earth earth=new Earth();
    }
</pre>
那么问题又来了，看起来我们在当前类中创建了一个该类的实例对象，但是我们知道java中非static修饰的变量是属于对象的，而这里我们并不能在外部创建类的实例对象，那么就还是无法获取到我们自己创建的实例。 
怎么办呢？此时外部能访问的只有这个类本身，那么如果要外部能获取到我们在类中创建的实例，就只能使这个实例是属于类的，也就是说需要让它变成static。
<pre>   
    public class Earth{
     private Earth(){  
     }
     static Earth earth=new Earth();
    }
</pre>
好了，这样一来，实际上一个基本的单例就算是实现了，我们已经保证了这个类只会有一个实例对象，直接使用Earth.earth来获取就好了。 
但是呢，这并不是我们要说的单例模式的规范写法。因为在java规范中，类的属性一般是需要对外隐藏的，也就是说这个自己创建的实例对象也需要声明为private。
<pre>
    public class Earth{
     private Earth(){  
     }
     private static Earth earth=new Earth();
    }
</pre>
这样的话，我们外部似乎又没法获取到这个类的对象了，怎么办呢？那就只能提供一个对外公开的方法，让外部能根据这个方法来获取到类的对象实例。当然了，这个方法自然也是要属于类的，这样才能在没有对象多的情况下调用：
## 饿汉式
<pre>
    public class Earth{
     private Earth(){ 
     }
     private static Earth earth=new Earth();
     public static Earth getInstance(){
      return earth;
     }
    }
</pre>
好了，到了这里，我们一个比较规范的单例模式的类便算是真正的完成了，既可以保证这个类的实例是单一的，又遵循了基本的java规范。 
总结一下就会发现其实就是三个简单而必须的步骤： 
**一、构造器私有化 **
**二、自己创建自己的私有并且静态的实例对象 **
**三、提供一个外部能访问的静态方法，返回自己的实例对象 **
上边这种模式，被称为单例模式中的饿汉式。 
何为饿汉？饿，可以理解为迫不及待，也就是等不及要吃东西。放在我们代码中，就是说在一开始就创建了实例对象，编译完就立马初始化了这个实例对象。

## 懒汉式
那么除开饿汉式，还有一个很常用的就是懒汉式了（实际还有一个双重锁模式，这里暂时不谈），基本代码如下：
<pre>
    public class Earth{
     private Earth(){
     }
     private static Earth earth=null;
     public static Earth getInstance(){
      if(earth==null){
        earth=new Earth();
      }
     return earth;
    }
</pre>
和上边饿汉式的区别在于，并没有在定义Earth变量的时候就给他初始化，而是给了一个初始值null。只不过这里虽然显示的写了null，实际上是可以不写的。 
因为即使我们不显示的给，在这个类编译完之后也会给所有的变量初始化赋值，基本类型有各自独特的初始值，比如int类型的是0，而引用类型的默认初始值都是null。 
与此同时，我们把具体对象的实例化放在了提供给外部调用的方法中，并且做了一定的判断，只有当这个对象是null的时候才会创建一个对象。 
这里的判断是很必要的，如果不做判断，那么每调用一次就是一个新的对象，无法保证单一实例，跟直接构造器创建就没了区别。 
那么有了代码，懒汉式也就比较好理解了。何谓懒汉？懒，就是做什么事都要一拖再拖，直到非做不可的时候才做。放在我们代码中，也就是在必须要获取实例对象的时候才会创建一个实例，在第一次调用getInstance方法的时候才会创建实例。

单例模式很简单，在实际项目中也应用非常的广泛。例如某些数据量很小的，直接定义死的，但是有时候可能因为业务需求的变化需要手动改变的一些公用数据，我们就可以不放在数据库，而是直接放在配置文件中，然后在项目中加载一次，放到内存中。